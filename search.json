[{"path":"https://immunomind.github.io/immundata/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contributing to immundata","title":"Contributing to immundata","text":"outlines propose change immundata. detailed discussion contributing tidyverse packages, please see development contributing guide code review principles.","code":""},{"path":"https://immunomind.github.io/immundata/CONTRIBUTING.html","id":"fixing-typos","dir":"","previous_headings":"","what":"Fixing typos","title":"Contributing to immundata","text":"can fix typos, spelling mistakes, grammatical errors documentation directly using GitHub web interface, long changes made source file. generally means ’ll need edit roxygen2 comments .R, .Rd file. can find .R file generates .Rd reading comment first line.","code":""},{"path":"https://immunomind.github.io/immundata/CONTRIBUTING.html","id":"bigger-changes","dir":"","previous_headings":"","what":"Bigger changes","title":"Contributing to immundata","text":"want make bigger change, ’s good idea first file issue make sure someone team agrees ’s needed. ’ve found bug, please file issue illustrates bug minimal reprex (also help write unit test, needed). See guide create great issue advice.","code":""},{"path":"https://immunomind.github.io/immundata/CONTRIBUTING.html","id":"pull-request-process","dir":"","previous_headings":"Bigger changes","what":"Pull request process","title":"Contributing to immundata","text":"Fork package clone onto computer. haven’t done , recommend using usethis::create_from_github(\"immunomind/immundata\", fork = TRUE). Install development dependencies devtools::install_dev_deps(), make sure package passes R CMD check running devtools::check(). R CMD check doesn’t pass cleanly, ’s good idea ask help continuing. Create Git branch pull request (PR). recommend using usethis::pr_init(\"brief-description--change\"). Make changes, commit git, create PR running usethis::pr_push(), following prompts browser. title PR briefly describe change. body PR contain Fixes #issue-number. user-facing changes, add bullet top NEWS.md (.e. just first header). Follow style described https://style.tidyverse.org/news.html.","code":""},{"path":"https://immunomind.github.io/immundata/CONTRIBUTING.html","id":"code-style","dir":"","previous_headings":"Bigger changes","what":"Code style","title":"Contributing to immundata","text":"New code follow tidyverse style guide. can use styler package apply styles, please don’t restyle code nothing PR. use roxygen2, Markdown syntax, documentation. use testthat unit tests. Contributions test cases included easier accept.","code":""},{"path":"https://immunomind.github.io/immundata/CONTRIBUTING.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of Conduct","title":"Contributing to immundata","text":"Please note immundata project released Contributor Code Conduct. contributing project agree abide terms.","code":""},{"path":"https://immunomind.github.io/immundata/SUPPORT.html","id":null,"dir":"","previous_headings":"","what":"Getting help with immundata","title":"Getting help with immundata","text":"Thanks using immundata! filing issue, places explore pieces put together make process smooth possible.","code":""},{"path":"https://immunomind.github.io/immundata/SUPPORT.html","id":"make-a-reprex","dir":"","previous_headings":"","what":"Make a reprex","title":"Getting help with immundata","text":"Start making minimal reproducible example using reprex package. haven’t heard used reprex , ’re treat! Seriously, reprex make R-question-asking endeavors easier (pretty insane ROI five ten minutes ’ll take learn ’s ). additional reprex pointers, check Get help! section tidyverse site.","code":""},{"path":"https://immunomind.github.io/immundata/SUPPORT.html","id":"where-to-ask","dir":"","previous_headings":"","what":"Where to ask?","title":"Getting help with immundata","text":"Armed reprex, next step figure ask. ’s question: start community.rstudio.com, /StackOverflow. people answer questions. ’s bug: ’re right place, file issue. ’re sure: let community help figure ! problem bug feature request, can easily return report . opening new issue, sure search issues pull requests make sure bug hasn’t reported /already fixed development version. default, search pre-populated :issue :open. can edit qualifiers (e.g. :pr, :closed) needed. example, ’d simply remove :open search issues repo, open closed.","code":""},{"path":"https://immunomind.github.io/immundata/SUPPORT.html","id":"what-happens-next","dir":"","previous_headings":"","what":"What happens next?","title":"Getting help with immundata","text":"efficient possible, development tidyverse packages tends bursty, shouldn’t worry don’t get immediate response. Typically don’t look repo sufficient quantity issues accumulates, ’s burst intense activity focus efforts. makes development efficient avoids expensive context switching problems, cost taking longer get back . process makes good reprex particularly important might multiple months initial report start working . can’t reproduce bug, can’t fix !","code":""},{"path":"https://immunomind.github.io/immundata/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Vadim . Nazarov. Author, maintainer.","code":""},{"path":"https://immunomind.github.io/immundata/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Nazarov V (2025). immundata: Unified Data Layer Large-Scale Single-Cell, Spatial Bulk Immunomics. R package version 0.0.4.9000, https://immunomind.com/.","code":"@Manual{,   title = {immundata: A Unified Data Layer for Large-Scale Single-Cell, Spatial and Bulk Immunomics},   author = {Vadim I. Nazarov},   year = {2025},   note = {R package version 0.0.4.9000},   url = {https://immunomind.com/}, }"},{"path":"https://immunomind.github.io/immundata/index.html","id":"id_-why-immundata","dir":"","previous_headings":"","what":"🤔 Why immundata?","title":"A Unified Data Layer for Large-Scale Single-Cell, Spatial and Bulk Immunomics","text":"Modern immunomics longer ends couple FASTQ files bar plot: now blend bulk AIRR-seq, single-cell V(D)J + GEX, spatial transcriptomics, clinical metadata public databases – often inside analysis notebook; Pipelines handle gigabytes today face deca-gigabytes next experiment; immune repertoire dataset must power multiple plots, dashboards, deep learning models reproducible months (years, ideally) later. immundata brings unified data layer large-scale single-cell, spatial bulk immunomics R. data-engineering backbone powered Arrow, DuckDB, duckplyr. immundata lets scale, mix , ultimately, analyse annotated AIRR data without rewriting biology workflow scratch time dataset grows 10×. [!WARNING] immundata still 0.x series. reach 1.0.0, breaking changes may appear minor/patch update (e.g. 0.2.1 → 0.3.0). attach package, sometimes ’ll see startup messages summarising important changes – please read . something used work suddenly fails, check updated documentation (?function_name) first. Tip: analysis depends specific behaviour, pin exact version renv use pak installation: ’ll keep publishing tagged releases full docs can always roll back needed. [!IMPORTANT] README huge. ’m kidding. Please consider using navigation. 🤔 immundata? 📦 Installation ⚡ Quick Start 🧬 Workflow Explained Load AIRR data Working metadata table files Receptor schema Repertoire schema Pre‑ post‑processing strategies Managing output & intermediate ImmunData files Writing ImmunData objects disk 🧿 ImmunData Object Filter Annotate Modify Basic analysis using immundata Advanced analysis using immunarch Bulk – RepSeq, AIRRSeq Paired-chain – scVDJseq technologies Single-cell – scRNAseq, scVDJseq, scTCRseq, scBCRseq Spatial – spatial transcriptomics cell coordinates Annotate immune receptors using external AIRR databases Immunogenicity – run external tools TCRdist annotate ImmunData Multi-locus data Multiple contigs TCR BCR-heavy chains multiple light chains Bulk single-cell data integration 🧠 Advanced Topics Citation License Author contributors Commercial usage 🤔 FAQ","code":"pak::pkg_install(\"immunomind/immundata@0.2.1\")"},{"path":[]},{"path":"https://immunomind.github.io/immundata/index.html","id":"prerequisites","dir":"","previous_headings":"📦 Installation","what":"Prerequisites","title":"A Unified Data Layer for Large-Scale Single-Cell, Spatial and Bulk Immunomics","text":"installing release pre-release version immundata, please install pak simplify installation package, just immundata: info needed available pak website.","code":"install.packages(\"pak\", repos = sprintf(\"https://r-lib.github.io/p/pak/stable/%s/%s/%s\", .Platform$pkgType, R.Version()$os, R.Version()$arch))"},{"path":"https://immunomind.github.io/immundata/index.html","id":"install-the-latest-version","dir":"","previous_headings":"📦 Installation","what":"Install the latest version","title":"A Unified Data Layer for Large-Scale Single-Cell, Spatial and Bulk Immunomics","text":"install latest release immundata, simply run: Mind install package GitHub instead CRAN. method much preferred due limitations CRAN reliance packages, distributed via pak well.","code":"pak::pkg_install(\"immunomind/immundata\")"},{"path":"https://immunomind.github.io/immundata/index.html","id":"other-installation-options","dir":"","previous_headings":"📦 Installation","what":"Other installation options","title":"A Unified Data Layer for Large-Scale Single-Cell, Spatial and Bulk Immunomics","text":"periodically release immundata CRAN. install CRAN, run willing try unstable yet bleeding edge features, hot fix open GitHub ticket, please install development version:","code":"pak::pkg_install(\"immundata\") pak::pkg_install(\"immunomind/immundata@dev\")"},{"path":"https://immunomind.github.io/immundata/index.html","id":"id_-quick-start","dir":"","previous_headings":"","what":"⚡ Quick Start","title":"A Unified Data Layer for Large-Scale Single-Cell, Spatial and Bulk Immunomics","text":"Use immune repertoire data packaged immundata quick dive. Replace system.file calls local file paths run code data.","code":"library(immundata)  # Metadata table with additional sample-level information md_path <- system.file(\"extdata/tsv\", \"metadata.tsv\", package = \"immundata\")  # Two sample files samples <- c(   system.file(\"extdata/tsv\", \"sample_0_1k.tsv\", package = \"immundata\"),    system.file(\"extdata/tsv\", \"sample_1k_2k.tsv\", package = \"immundata\")   )  # Read the metadata table md <- read_metadata(md_path)  # Pass the file paths and the metadata table to the function to read the dataset into R imdata <- read_repertoires(path          = samples,                            schema        = c(\"cdr3_aa\", \"v_call\"),                            metadata      = md,                            output_folder = \"./immundata-quick-start\")  # Print the resultant object in the detailed yet manageable format imdata  # Check the folder immundata created - this is where your dataset resides now list.files(\"./immundata-quick-start\")  # Read sections below for data analysis"},{"path":"https://immunomind.github.io/immundata/index.html","id":"id_-workflow-explained","dir":"","previous_headings":"","what":"🧬 Workflow Explained","title":"A Unified Data Layer for Large-Scale Single-Cell, Spatial and Bulk Immunomics","text":"immundata splits workflow two clear phases: Ingestion – convert AIRR files special format saved disk, read tidy immundata::ImmunData object Transformation – explore, annotate, filter compute object go details phase, three straightforward yet essential immundata concepts keep mind. concepts set apart data-frame-based AIRR libraries. extension, concepts affect work even think data analysis packages immunarch use immundata backbone computations.","code":""},{"path":"https://immunomind.github.io/immundata/index.html","id":"concepts","dir":"","previous_headings":"🧬 Workflow Explained","what":"Concepts","title":"A Unified Data Layer for Large-Scale Single-Cell, Spatial and Bulk Immunomics","text":"Units: chain -> barcode -> receptor Chain one V(D)J rearranged molecule / contig / chemistry read (e.g. single TRA, TRB, IGH, IGL). minimally possible data unit, building block everything. case single-chain data, chain barcode. Never changes ingest; can always drill back exact sequence. Barcode physical container stores zero, one, many chains. single‑cell ’s droplet == cell; bulk ’s assembled “clonotype”; spatial ’s spot. Barcode sometimes equals cell. biological unit “stores” relevant biological data uses aggregation chains computing counts receptors coming different barcodes. Inherits per‑cell / per‑sample metadata add. Receptor logical unit. logical grouping chains want treat one biological receptor. minimal unit AIRR statistics. two components : receptor features receptor chains, alltogether comprising receptor schema define order downstream analysis. Receptor features usually CDR3 amino acid sequences CDR3 amino acid sequences plus Variable gene segment. Receptor chains can : single chain, α+β pair, heavy+light pair, even chains sharing CDR3/V/J. summarise: chains immundata stores information, barcodes bundle chains together, receptors minimal units repertoire statistics computed. Aggregation: defining receptors repertoires moment data leave AIRR-assembly tool Cell Ranger, handed ocean individual V(D)J chains, yet every biological question care phrased terms receptors (“αβ TCR”) repertoires (“receptors donor day 30”). “receptors logical units”, underlying assumption second concept based upon researchers work rearrangements think receptors. immundata formalises climb raw chains higher-order concepts controlled aggregation – explicit, user-defined rules transform data without obscuring origin. function agg_receptors() lets declare one receptor means study. choose schema – perhaps “pair chains share barcode complementary α β loci” “group every IGH whatever IGL shares CDR3 amino-acid sequence.” function re-aggregates data returns new ImmunData object, keep previous receptor definition intact; every receptor now stable identifier can traced back constituent chains barcode. need touch downstream pipeline – just change input. function agg_repertoires() states receptors bundled biologically meaningful cohorts: receptors biopsy, therapy responder, single-cell-defined cluster, combination metadata columns. result physical idata$repertoires table basic statistics (numbers chains, barcodes, unique receptors), preserving direct links receptors aggregates. aggregation steps live pipeline rather buried inside helper functions, deliver two major pay-offs: Convenience rigour: can run high-level computations – Jaccard coefficients, diversity indices – knowing exact receptor definition stored alongside result, never mis-specify parameters \"cdr3+v\"; Provenance data lineage design: every receptor records every chain contains, every repertoire records every receptor, full recipe stored object’s metadata. Six months later – six reviewers later – can trace summary statistic back precise chains produced , enabling fully reproducible pipelines hidden transformations. Pipeline-based execution: immutability materialisation explicit data lineage talked concepts 1 & 2 pays dividend every step re-playable. immundata treats analysis pipeline immutable transformations. function returns fresh ImmunData object, leaving parent untouched; full chain objects records data travelled raw chains final statistics. immunomics datasets started regularly outgrow RAM, objects live memory default. tables persisted column-compressed Parquet files “materialised” – pulled RAM – computation truly needs , typically crunch subset emit final numbers repertoire-overlap indices. 10 GB dataset fits memory, behaviour invisible: DuckDB streams file, get -memory frame, life goes . 100 GB experiment, code still runs; heavy joins spill disk, intermediate results cached downstream steps can reuse without recomputation. Thinking pipelines therefore means two things: Cache matters: create intermediate ImmunData objects hit expensive step, write disk; next run can pick . prime example computing edit distances patterns sequences. Assume re-execution: colleague (future-bigger cluster) able rerun pipeline.R end--end without interactive tinkering arrive result byte--byte. engineering stay behind curtain. Downstream packages adopt immundata backbone expose high-level verbs compute_diversity() plot_overlap(); user need touch ImmunData, DuckDB, Parquet. ideal scenario never learn -disk database powers workflow – never . Leave data engineering data engineers (, sadly, bioinformaticians – feel pain); keep focus focus users biology. sophisticated enough already. now, let’s dive work immundata.","code":""},{"path":"https://immunomind.github.io/immundata/index.html","id":"phase-1-ingestion","dir":"","previous_headings":"🧬 Workflow Explained","what":"Phase 1: Ingestion","title":"A Unified Data Layer for Large-Scale Single-Cell, Spatial and Bulk Immunomics","text":"Steps marked (!) non-optional. goal ingestion phase turn folder AIRR-seq files immutable -disk ImmunData dataset. Read metadata: read_metadata() pulls sample- donor-level information, therapy arm, HLA type, age, etc., stores data frame can pass main reading functions read_repertoires. Attaching context early means every chain read later already “knows” patient time-point belongs . can safely skip don’t per-sample pr per-donor metadata. Read repertoire files: read_repertoires() streams Parquet/CSV/TSV files straight DuckDB powers ImmunData objects. Preprocess: read step may pass preproc = recipe argument read_repertoires preprocess data aggregating receptors: drop unused columns, strip non-productive sequences, translate field names AIRR schema, de-duplicate contigs, etc. logic declarative, re-runs produce identical results. Aggregate receptors: Receptor schema define receptor – logical unit analysis. read_repertoires collapses chains receptors accordingly assigns stable unique identifier. Postprocess: mirror step preprocess: convenient hook run QC checks, add derived fields, attach reference-gene annotations, compute per-chain quality metrics dataset ready. can pass number steps executed sequential order. Aggregate repertoires #1: already know group chains receptors, perhaps \"Sample\" \"Donor\" columns metadata, can pass repertoire_schema = c(\"Sample\") read_repertoires(). Otherwise, skip define repertoires later (common single-cell workflows need cluster labels first). Write data disk: read_repertoires always persists just built: column-compressed Parquet parts plus human-readable metadata JSON. , downstream steps can reopen dataset instantly without touching raw AIRR files . Aggregate repertoires #2: Call agg_repertoires() later withheld grouping additional annotations available, e.g. donor + cell cluster.","code":"┌───────┐       │ files │       └───────┘           │           ▼    read_metadata()    ──── Read metadata           │           ▼   read_repertoires()  ──┬─ Read repertoire files (!)           │             │      ▼           │             │  Preprocess           │             │      ▼           │             │  Aggregate receptors (!)           │             │      ▼           │             │  Postprocess           │             │      ▼           │             │  Aggregate repertoires #1           │             │      ▼           │             └─ Write data on disk (!)           ▼    agg_repertoires()  ──── Aggregate repertoires #2           │           ▼     ┌───────────┐     │ ImmunData │     └───────────┘"},{"path":"https://immunomind.github.io/immundata/index.html","id":"phase-2-transformation","dir":"","previous_headings":"🧬 Workflow Explained","what":"Phase 2: Transformation","title":"A Unified Data Layer for Large-Scale Single-Cell, Spatial and Bulk Immunomics","text":"Transformation loop annotation → modification computation → visualisation, always producing new ImmunData leaving parent intact. immutability turns every notebook reproducible pipeline. Import external annotations ImmunData: annotate_immundata() (thin wrappers annotate_barcodes() / annotate_receptors()) merges labels Seurat/AnnData/TCRdist/anything can expressed keyed data frame main table, chain corresponding annotation. Aggregate repertoires: Now extra labels present, might regroup receptors, example, donor × cell-state. Filter receptors repertoires: filter_immundata() accepts tidy-verse predicates chains, receptors, repertoires. Create modify columns, compute statistics: step, compute statistics per-repertoire per-receptor, using input receptor features. several scenarios depending try achieve. use immunarch common analysis functions. package automatically annotate receptors/barcodes/chains (!) repertoires (!!) possible; simply mutate whole dataset using dplyr syntax, like compute edit distance specific pattern using mutate_immundata; complex compute requires function apply values probably supported duckplyr. See 🧠 Advanced Topics details. Save / plot #1: Cache ImmunData. Use ggplot2 visualise statistics, computed ImmunData. Annotate ImmunData computed statistics: annotate_immundata() () joins freshly minted statistics back canonical dataset. Save / plot #2: Save ImmunData new annotations disk. Plot results analysis. Export ImmunData annotations: Write annotated data back cell-level dataset (Seurat / AnnData) subsequent analysis. Additionally, write ImmunData disk needed.","code":"┌───────────┐       ┌────────────────────────────┐       │ ImmunData │       │ AnnData / Seurat / TCRdist │       └───────────┘       │ seur@meta.data / adata.obs │             │             └────────────────────────────┘             │                             │             ├─────────────────────────────┘             │             ▼    annotate_immundata()    ──── Import external annotations to ImmunData             │             ▼      agg_repertoires()     ──── Aggregate repertoires             │             ▼     filter_immundata()     ──── Filter receptors or repertoires             │             ▼     mutate_immundata()     ──── Create or modify columns, compute statistics             │             │     ┌────────────────┐             ├────►│ save / plot #1 │             │     └────────────────┘             ▼    annotate_immundata()    ──── Annotate ImmunData with the computed statistics             │             │     ┌────────────────┐             ├────►│ save / plot #2 │             │     └────────────────┘             │             ▼ ┌────────────────────────┐ │seur@meta.data[:] <- ...│ ──── Export ImmunData annotations │    adata.obs = ...     │ └────────────────────────┘"},{"path":[]},{"path":"https://immunomind.github.io/immundata/index.html","id":"load-airr-data","dir":"","previous_headings":"💾 Ingestion","what":"Load AIRR data","title":"A Unified Data Layer for Large-Scale Single-Cell, Spatial and Bulk Immunomics","text":"immundata provides flexible system loading immune receptor repertoire files different sources – CSV, TSV Parquet files, possibly gzipped, optionality. main function read_repertoires(). four ways pass file paths one convering data existing immunarch pre-1.0 list objects $data $meta. Pass single file name: just one AIRR file: Pass vector file names: multiple files vector: immundata automatically merges (depending chosen schema), writes aggregated data single directory Parquet files, produces single-cell ImmunData object. Think huge table instead smaller multiple repertoire tables. Pass glob pattern: files follow consistent naming pattern, can leverage shell globs: Behind scenes, read_repertoires() expands glob Sys.glob(...), merges data, produces single ImmunData. Use metadata file: Sometimes need control data source (e.g. consistent sample naming, extra columns). case: Load metadata read_metadata(). Pass resulting data frame read_repertoires(path = \"<metadata>\", ..., metadata = md_table). Mind \"<metadata>\" string pass function. indicates take file paths input metadata table. example code: approach unifies sample-level metadata (e.g. donor ID, timepoint) repertoire data inside single ImmunData. can pass metadata table separately along list files previous examples without “” directive, case need check correctness filepaths . quite cumbersome, say least. information work metadata files, please read next section. Convert immunarch lists: Pass immunarch data lists from_immunarch() create ImmunData objects.","code":"library(immundata)  inp_file <- system.file(\"extdata/tsv\", \"sample_0_1k.tsv\", package = \"immundata\")  idata <- read_repertoires(   path   = inp_file,   schema = c(\"cdr3_aa\", \"v_call\") )  print(idata) library(immundata)  inp_file1 <- system.file(\"extdata/tsv\", \"sample_0_1k.tsv\", package = \"immundata\") inp_file2 <- system.file(\"extdata/tsv\", \"sample_1k_2k.tsv\", package = \"immundata\")  file_vec <- c(inp_file1, inp_file2)  idata <- read_repertoires(   path   = file_vec,   schema = c(\"cdr3_aa\", \"v_call\") )  print(idata) library(immundata)  folder_with_files <- system.file(\"extdata/tsv\", \"\", package = \"immundata\")  glob_files <- paste0(folder_with_files, \"sample*.tsv\")  print(glob_files) # The output is something like \"/Library/Frameworks/.../immundata/extdata/tsv/*\" # Mind the star \"*\" at the end  # For example, all AIRR files in the 'samples/' folder idata <- read_repertoires(   path   = glob_files,   schema = c(\"cdr3_aa\", \"v_call\") )  print(idata) library(immundata)  md_path <- system.file(\"extdata/tsv\", \"metadata.tsv\", package = \"immundata\")  md_table <- read_metadata(md_path)  print(md_table) # The column \"File\" stores the file paths. If you have a different column name # for files, use the `metadata_file_col = \"<your column name>\"` argument. # A tibble: 2 × 5   File                       Therapy Response Prefix filename   <chr>                      <chr>   <chr>    <chr>  <chr> 1 /.../immundata-/inst/extd… ICI     FR       S1_    /Users/… 2 /.../immundata-/inst/extd… CAR-T   PR       S2_    /Users/… idata <- read_repertoires(   path     = \"<metadata>\",   metadata = md_table,   schema   = c(\"cdr3_aa\", \"v_call\") )  print(idata) library(immundata) # Install old immunarch: # pak::pkg_install(\"immunomind/immunarch@0.9.1\") data(immdata, package = \"immunarch\")  idata <- from_immunarch(   imm = immdata,    schema = c(\"CDR3.aa\", \"V.name\"),    output_folder = \"./immdata-test\")  print(idata)"},{"path":"https://immunomind.github.io/immundata/index.html","id":"working-with-metadata-table-files","dir":"","previous_headings":"💾 Ingestion","what":"Working with metadata table files","title":"A Unified Data Layer for Large-Scale Single-Cell, Spatial and Bulk Immunomics","text":"Metadata tables store sample-level information. immundata loads metadata, annotates every receptor given sample (file) corresponding metadata fields. example, sample “Therapy” = “CAR‑T”, receptors sample receive “Therapy” value. can aggregate receptors donor, tissue, field run analysis repertoires (see next sections aggregations). [!WARNING] current version, “metadata” “repertoire schema” , meaning can’t get metadata field idata$repertoires haven’t define repertoires using field. implement next versions; now, please consider using dplyr::left_join merge metadata repertoires table together.","code":"library(immundata)  md_path <- system.file(\"extdata/tsv\", \"metadata.tsv\", package = \"immundata\") md_table <- read_metadata(md_path) Rows: 2 Columns: 4 ── Column specification ───────────────────────────────────────────────────────── Delimiter: \"\\t\" chr (4): File, Therapy, Response, Prefix  ℹ Use `spec()` to retrieve the full column specification for this data. ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. ℹ Found 2/2 repertoire files from the metadata on the disk ✔ Metadata parsed successfully print(md_table) # A tibble: 2 × 5   File                       Therapy Response Prefix filename   <chr>                      <chr>   <chr>    <chr>  <chr> 1 /.../immundata-/inst/extd… ICI     FR       S1_    /Users/… 2 /.../immundata-/inst/extd… CAR-T   PR       S2_    /Users/…"},{"path":"https://immunomind.github.io/immundata/index.html","id":"receptor-schema","dir":"","previous_headings":"💾 Ingestion","what":"Receptor schema","title":"A Unified Data Layer for Large-Scale Single-Cell, Spatial and Bulk Immunomics","text":"immundata lets decide receptor means study specifying: Feature columns - fields make receptor unique. Usually \"cdr3_aa\" \"v_call\" columns. Chains keep / pair - e.g. TRA pair TRA + TRB. feature columns, can usually pass character vector columns functions. advanced case multiple chain data, immundata provides helper function make_receptor_schema() building schemas: Chain-agnostic Used bulk pre-filtered immune repertoire data. filtering chain data TRA TRB. unique combination features schema vector assigned unique receptor identifier counts receptor. example , receptor features “cdr3_aa” “v_call” columns - CDR3 amino acid sequence V gene segment columns respectively. Single-chain [!NOTE] Please note single-chain option (!) remove multiple chains per cell - yet. words, get multiple receptors per barcode. paired chain option filter chains don’t max number reads umis per barcode. receptor numbers sequences differ significantly. Used paired-chain data single-cell data focus analysis immune receptors specific chain. data pre-filtered leave data units specified chain . Paired-chain want full αβ (heavy‑light) receptors, immundata can pair two chains originate barcode keep, locus, chain highest UMI/reads. single unique receptor identifier assigned pair. data pre-filtered loci target chains. Within barcode×locus chain max umis reads selected. Barcodes lacking either chain dropped receptor table. Cheat-sheet arguments read_repertoires: ¹ pass barcodes, ’re stored used counting .","code":"schema <- make_receptor_schema(   features = c(\"cdr3_aa\", \"v_call\"),   chains   = c(\"TRA\", \"TRB\") ) library(immundata)  inp_file <- system.file(\"extdata/tsv\", \"sample_0_1k.tsv\", package = \"immundata\")  schema <- c(\"cdr3_aa\", \"v_call\")  idata <- read_repertoires(   path   = inp_file,   schema = schema )  print(idata) library(immundata)  inp_file <- system.file(\"extdata/single_cell\", \"lt6.csv.gz\", package = \"immundata\")  schema <- make_receptor_schema(   features = c(\"cdr3\", \"v_call\"),   chains   = \"TRA\" )  idata <- read_repertoires(   path        = inp_file,   schema      = schema,   barcode_col = \"barcode\",   locus_col   = \"locus\",   preprocess  = make_default_preprocessing(\"10x\") )  print(idata) library(immundata)  inp_file <- system.file(\"extdata/single_cell\", \"lt6.csv.gz\", package = \"immundata\")  schema <- make_receptor_schema(   features = c(\"cdr3\", \"v_call\"),   chains   = c(\"TRA\", \"TRB\") )  idata <- read_repertoires(   path        = inp_file,   schema      = schema,   barcode_col = \"barcode\",         # required for pairing   locus_col   = \"locus\",           # column that says \"TRA\" / \"TRB\"   umi_col     = \"umis\",            # choose chain with max UMIs per locus   preprocess  = make_default_preprocessing(\"10x\") )  print(idata)"},{"path":"https://immunomind.github.io/immundata/index.html","id":"repertoire-schema","dir":"","previous_headings":"💾 Ingestion","what":"Repertoire schema","title":"A Unified Data Layer for Large-Scale Single-Cell, Spatial and Bulk Immunomics","text":"compute repertoire‑level statistics gene‑segment usage, Jaccard coefficient, incidence public receptors, first need define repertoire. immundata repertoire simply group receptors share one values annotation columns. Just like receptors, can pass schema – character vector column names – specify receptors grouped repertoires. bulk data, usually, rely metadata table. useful want aggregate together receptors donor tissue, analyse . may want filter non-responders analyse responders . [!NOTE] Don’t confuse grouping immune repertoires grouping plots. define immune repertoire, proportions recomputed, receptor assigned unique repertoire identifier faster computations. create virtual “tables” immune receptors, can work separately using filters mutations, despite data still stored huge table receptors. plot data, first compute statistics per defined immune repertoire, group . can later plot re‑group resulting statistics, order operations matters. true power regrouping repertoires opens work single-cell data.","code":"library(immundata)        inp_file <- system.file(\"extdata/single_cell\", \"lt6.csv.gz\", package = \"immundata\") md_file <- system.file(\"extdata/single_cell\", \"metadata.tsv\", package = \"immundata\") md_table <- read_metadata(md_file) schema <- make_receptor_schema(features = c(\"cdr3\", \"v_call\"), chains   = c(\"TRA\", \"TRB\"))  idata <- read_repertoires(   path        = inp_file,   schema      = schema,   metadata    = md_table,   barcode_col = \"barcode\",         # required for pairing   locus_col   = \"locus\",           # column that says \"TRA\" / \"TRB\"   umi_col     = \"umis\",            # choose chain with max UMIs per locus   preprocess  = make_default_preprocessing(\"10x\") )  cells_file <- system.file(\"extdata/single_cell\", \"cells.tsv.gz\", package = \"immundata\") cells <- readr::read_tsv(cells_file)  # External cell annotations print(cells)  # Annotate data with cell clusters idata <- annotate_barcodes(   idata = idata,   annotations = cells[c(\"barcode\", \"ident\")],    annot_col = \"barcode\",    keep_repertoires = FALSE )  # Aggregate repertoires to make cluster-specific repertoires idata <- idata |> agg_repertoires(schema = \"ident\")  # Take a look at the $repertoires table print(idata)"},{"path":"https://immunomind.github.io/immundata/index.html","id":"preprocessing-and-postprocessing-strategies","dir":"","previous_headings":"💾 Ingestion","what":"Preprocessing and postprocessing strategies","title":"A Unified Data Layer for Large-Scale Single-Cell, Spatial and Bulk Immunomics","text":"[!CAUTION] 🚧 construction. 🚧 … progress … removing columns (“” default) filtering non productive (“” default) Barcode prefix Provide column named “Prefix” metadata make_default_postprocessing() can automatically add prefix barcodes make barcodes unique resultant dataset.","code":""},{"path":"https://immunomind.github.io/immundata/index.html","id":"managing-the-output-and-intermediate-immundata-files","dir":"","previous_headings":"💾 Ingestion","what":"Managing the output and intermediate ImmunData files","title":"A Unified Data Layer for Large-Scale Single-Cell, Spatial and Bulk Immunomics","text":"[!CAUTION] 🚧 construction. 🚧 default, read_repertoires() writes created Parquet files directory named immundata_<first filen name>. Consider passing output_folder read_repertoires() want specify output path.","code":""},{"path":"https://immunomind.github.io/immundata/index.html","id":"writing-immundata-objects-on-disk","dir":"","previous_headings":"💾 Ingestion","what":"Writing ImmunData objects on disk","title":"A Unified Data Layer for Large-Scale Single-Cell, Spatial and Bulk Immunomics","text":"Use write_immundata save ImmunData objects. might need - save intermediate files, e.g., computing levenshtein distance specific receptors database. case, wouldn’t need recompute distances time.","code":""},{"path":"https://immunomind.github.io/immundata/index.html","id":"id_-immundata-object","dir":"","previous_headings":"","what":"🧿 ImmunData Object","title":"A Unified Data Layer for Large-Scale Single-Cell, Spatial and Bulk Immunomics","text":"ImmunData object self-describing container holds immune repertoire dataset. ImmunData objects several slots accessible via <object>$<slot>: ImmunData$receptors – virtual table created demand $annotations. One row per receptor defined $schema_receptor; guaranteed stable key imd_receptor_id. aggregated view dataset, meaning fields receptor features (cdr3, v_call) unique respect row, .e., row unique. ImmunData$annotations – main table holds data. One row per chain (per cell barcode case single-chained data). Holds every AIRR field (cdr3, v_call, umis, etc.) plus metadata imported (sample_id, tissue, distances patterns). ImmunData$repertoires – physical table produced agg_repertoires(). row repertoire (sample, donor, cluster) carries pre-computed counts: number receptors, barcodes, chains. ImmunData$schema_receptor – recipe says collapse chains receptors: features make identical (e.g. cdr3_aa, v_call) loci must pair (e.g. α+β, heavy+light, single-chain). ImmunData$schema_repertoire – grouping keys used bundle receptors repertoires (e.g. sample_id, donor_id, time_point, etc.). Lets define multiple biological layers inside one dataset (e.g. patient level vs. patient × cluster level) switch . can change slots directly. self-describing container harsh life, full dangers unwanted adventures, requires constant re-evaluation goes . immundata functions internally. Every transformation returns new ImmunData, can stash (trash) intermediate versions disk reproduce branch analysis. Example: Printed ImmunData idata:","code":"library(immundata)        inp_files <- paste0(system.file(\"extdata/single_cell\", \"\", package = \"immundata\"), \"/*.csv.gz\") md_file <- system.file(\"extdata/single_cell\", \"metadata.tsv\", package = \"immundata\") md_table <- read_metadata(md_file) cells_file <- system.file(\"extdata/single_cell\", \"cells.tsv.gz\", package = \"immundata\") cells <- readr::read_tsv(cells_file)  schema <- make_receptor_schema(features = c(\"cdr3\", \"v_call\"), chains = c(\"TRB\"))  idata <- read_repertoires(path = inp_files, schema = schema, metadata = md_table, barcode_col = \"barcode\", locus_col = \"locus\", umi_col = \"umis\", preprocess = make_default_preprocessing(\"10x\"), repertoire_schema = \"Tissue\")  print(idata) ── ImmunData ───────────────────────────────────────────────────────────────────────────────────────────  ── Receptors: ──  # A duckplyr data frame: 3 variables    imd_receptor_id cdr3               v_call              <int> <chr>              <chr>  1            2514 CASSVHPQYF         TRBV2  2            7687 CAWSGQGWGGSTDTQYF  TRBV30  3            2515 CASSPRPGSTGELFF    TRBV18  4            5111 CASSQGLGVSYEQYF    TRBV4-1  5            7688 CASSHGQGRTGELFF    TRBV7-2  6            7689 CASGLRRGRDSGANVLTF TRBV19  7            2516 CSAHRGLGNQPQHF     TRBV20-1  8            5112 CASSPQGVSNQPQHF    TRBV7-2  9               1 CASSSVSGNSPLHF     TRBV7-9 10            5113 CASPLGALTDTQYF     TRBV2 # ℹ more rows # ℹ Use `print(n = ...)` to see more rows  ── Annotations: ──  # A duckplyr data frame: 23 variables    barcode   locus v_call d_call j_call c_gene productive cdr3  cdr3_nt reads  umis filename imd_barcode    <chr>     <chr> <chr>  <chr>  <chr>  <chr>  <chr>      <chr> <chr>   <dbl> <dbl> <chr>    <chr>  1 AAACCTGA… TRB   TRBV2  None   TRBJ2… TRBC2  True       CASS… TGTGCC… 13736    11 /Users/… LB6_AAACCT…  2 AAACCTGC… TRB   TRBV30 TRBD1  TRBJ2… TRBC2  True       CAWS… TGTGCC…  4062     5 /Users/… LB6_AAACCT…  3 AAACCTGC… TRB   TRBV18 TRBD2  TRBJ2… TRBC2  True       CASS… TGTGCC…  8617    10 /Users/… LB6_AAACCT…  4 AAACCTGG… TRB   TRBV4… TRBD1  TRBJ2… TRBC2  True       CASS… TGCGCC…  6811     5 /Users/… LB6_AAACCT…  5 AAACCTGG… TRB   TRBV7… TRBD1  TRBJ2… TRBC2  True       CASS… TGTGCC… 16836    15 /Users/… LB6_AAACCT…  6 AAACCTGT… TRB   TRBV19 TRBD2  TRBJ2… TRBC2  True       CASG… TGTGCC…  8805     9 /Users/… LB6_AAACCT…  7 AAACCTGT… TRB   TRBV2… TRBD1  TRBJ1… TRBC1  True       CSAH… TGCAGT…  8311     6 /Users/… LB6_AAACCT…  8 AAACGGGA… TRB   TRBV7… TRBD1  TRBJ1… TRBC1  True       CASS… TGTGCC…  3390     3 /Users/… LB6_AAACGG…  9 AAACGGGA… TRB   TRBV7… TRBD2  TRBJ1… TRBC1  True       CASS… TGTGCC…  4956     4 /Users/… LB6_AAACGG… 10 AAACGGGA… TRB   TRBV2  TRBD1  TRBJ2… TRBC2  True       CASP… TGTGCC…  5625     4 /Users/… LB6_AAACGG… # ℹ more rows # ℹ 10 more variables: imd_chain_id <int>, imd_receptor_id <int>, imd_n_chains <dbl>, File <chr>, #   Tissue <chr>, Prefix <chr>, imd_count <dbl>, imd_repertoire_id <int>, imd_proportion <dbl>, #   n_repertoires <int> # ℹ Use `print(n = ...)` to see more rows  ── Receptor schema: ──  features: → cdr3 → v_call chains: → TRB   ── Repertoire schema: ──  → Tissue   ── List of repertoires: ──  # A tibble: 3 × 4   imd_repertoire_id Tissue n_barcodes n_receptors               <int> <chr>       <dbl>       <int> 1                 1 Blood        4085        3976 2                 2 Normal       6797        2950 3                 3 Tumor        7832        3962"},{"path":"https://immunomind.github.io/immundata/index.html","id":"id_-transformation","dir":"","previous_headings":"","what":"🛠 Transformation","title":"A Unified Data Layer for Large-Scale Single-Cell, Spatial and Bulk Immunomics","text":"running code following subsections, execute code . Mind example purposes, data uses TRB locus . Change input receptor schema column names adapt paired-chain case.","code":"library(immundata)        inp_files <- paste0(system.file(\"extdata/single_cell\", \"\", package = \"immundata\"), \"/*.csv.gz\") md_file <- system.file(\"extdata/single_cell\", \"metadata.tsv\", package = \"immundata\") md_table <- read_metadata(md_file) cells_file <- system.file(\"extdata/single_cell\", \"cells.tsv.gz\", package = \"immundata\") cells <- readr::read_tsv(cells_file)  schema <- make_receptor_schema(features = c(\"cdr3\", \"v_call\"), chains = c(\"TRB\"))  idata <- read_repertoires(path = inp_files, schema = schema, metadata = md_table, barcode_col = \"barcode\", locus_col = \"locus\", umi_col = \"umis\", preprocess = make_default_preprocessing(\"10x\"), repertoire_schema = \"Tissue\")"},{"path":"https://immunomind.github.io/immundata/index.html","id":"filter","dir":"","previous_headings":"🛠 Transformation","what":"Filter","title":"A Unified Data Layer for Large-Scale Single-Cell, Spatial and Bulk Immunomics","text":"key functions filtering filter() (dplyr-compatible) filter_immundata(), function slightly different arguments due necessity comply dplyr interface. Repertoires reaggregated automatically. Functions filter_receptors() filter_barcodes() used filter receptor barcode identifiers, correspondingly. filter data, simply pass predicates like dplyr. Optionally, can pass seq_options allow filter exact sequence match, regex pattern, sequence distances using hamming edit/levenshtein distances. can pass multiple patterns via patterns = c(\"pattern_1\", \"pattern_2\"). Filter annotation Chain filters together Filter sequence distance Filter receptor identifiers Filter barcodes Filter repertoire","code":"idata |> filter(v_call == \"TRBV2\")  idata |> filter(Tissue == \"Blood\") # this expression: idata |> filter(v_call == \"TRBV2\", imd_proportion >= 0.0002)  # is the same as this one: idata |> filter(v_call == \"TRBV2\") |> filter(imd_proportion >= 0.0002) idata |> filter(seq_options = make_seq_options(patterns = \"CASSELAGYRGEQYF\", query_col = \"cdr3\", method = \"lev\", max_dist = 3))  idata |> filter(v_call == \"TRBV2\", seq_options = make_seq_options(patterns = \"CASSELAGYRGEQYF\", query_col = \"cdr3\", method = \"lev\", max_dist = 3)) idata |> filter_receptors(c(1,2,3)) target_bc <- cells$barcode[1:3] idata |> filter_barcodes(target_bc) idata |> filter(imd_repertoire_id == 1)  idata |> filter(Tissue %in% c(\"Blood\", \"Tumor\"))"},{"path":"https://immunomind.github.io/immundata/index.html","id":"annotate","dir":"","previous_headings":"🛠 Transformation","what":"Annotate","title":"A Unified Data Layer for Large-Scale Single-Cell, Spatial and Bulk Immunomics","text":"key function annotations annotate annotate_immundata. Functions annotate_receptors(), annotate_barcodes() annotate_chains() light-weight wrappers around annotate_immundata(). Annotate column Annotate receptor identifiers Annotate barcodes","code":"idata2 <- annotate(idata = idata, annotations = cells[c(\"barcode\", \"ident\")], by = c(imd_barcode = \"barcode\"), keep_repertoires = FALSE) idata2 <- idata2 |> filter(!is.na(ident)) idata2 <- idata2 |> agg_repertoires(schema = \"ident\")  print(idata2) idata2 <- annotate_receptors(idata = idata, annotations = tibble::tibble(receptor = c(1,2,3), important_data = c(\"A\", \"B\", \"C\")), annot_col = \"receptor\")  idata2 |> filter(important_data %in% c(\"A\", \"B\")) idata2 <- annotate_barcodes(idata = idata, annotations = cells[c(\"barcode\", \"ident\")],  annot_col = \"barcode\", keep_repertoires = FALSE) idata2 <- idata2 |> filter(!is.na(ident)) idata2 <- idata2 |> agg_repertoires(schema = \"ident\")  print(idata2)"},{"path":"https://immunomind.github.io/immundata/index.html","id":"modify","dir":"","previous_headings":"🛠 Transformation","what":"Modify","title":"A Unified Data Layer for Large-Scale Single-Cell, Spatial and Bulk Immunomics","text":"key functions mutate (dplyr-compatible) / mutate_immundata functions downstream analysis tools. Add transform one several annotation columns Add columns sequence distance patterns Modify subset column values","code":"idata |> mutate(new_column = \"value\")  idata |> mutate(big_chains = umis >= 10)  # You can use duckdb functions via `dd$<function>` idata |> mutate(dist_to_pattern = dd$levenshtein(cdr3, \"CASSSVSGNSPLHF\")) patterns <- c(\"CASSVHPQYF\", \"CAWSGQGWGGSTDTQYF\", \"CASSPRPGSTGELFF\") idata |> mutate(seq_options = make_seq_options(query_col = \"cdr3\", patterns = patterns, method = \"lev\"))  idata |> mutate(seq_options = make_seq_options(query_col = \"cdr3\", patterns = patterns, method = \"lev\", name_type = \"pattern\")) idata |> mutate(found_pattern = if_else(cdr3 == \"CASSVHPQYF\", 1, 0))"},{"path":[]},{"path":"https://immunomind.github.io/immundata/index.html","id":"basic-analysis-using-immundata","dir":"","previous_headings":"📈 Analysis","what":"Basic analysis using immundata","title":"A Unified Data Layer for Large-Scale Single-Cell, Spatial and Bulk Immunomics","text":"","code":"# Find receptors from several repertoires which have >60 abundance # and get their barcodes idata2 <- idata |> filter(imd_count >= 60) target_chains <- idata2$annotations |> select(imd_barcode, imd_count, cdr3, v_call, Tissue) |> collect() target_chains  # You can then annotate those receptors in your single-cell data using # the `imd_barcode` column as a key."},{"path":"https://immunomind.github.io/immundata/index.html","id":"advanced-analysis-using-immundata","dir":"","previous_headings":"📈 Analysis","what":"Advanced analysis using immundata","title":"A Unified Data Layer for Large-Scale Single-Cell, Spatial and Bulk Immunomics","text":"","code":"# Install the latest pre-1.0 version of immunarch # pak::pkg_install(immunomind/immunarch)  library(immunarch)  ov_heatmap <- airr_public_index(idata, \"jaccard\") pheatmap::pheatmap(ov_heatmap)  clonal_space_homeo <- airr_clonality(idata, \"prop\") ggplot2::ggplot(data = clonal_space_homeo) + geom_col(aes(x = Tissue, y = occupied_prop, fill = clonal_prop_bin)) + ggplot2::theme_bw()"},{"path":"https://immunomind.github.io/immundata/index.html","id":"id_-use-cases","dir":"","previous_headings":"","what":"🧩 Use Cases","title":"A Unified Data Layer for Large-Scale Single-Cell, Spatial and Bulk Immunomics","text":"[!TIP] Tutorial immundata + immunarch available ecosystem website. Read previous section analysis. section still construction.","code":""},{"path":"https://immunomind.github.io/immundata/index.html","id":"bulk--repseq-airrseq","dir":"","previous_headings":"🧩 Use Cases","what":"Bulk – RepSeq, AIRRSeq","title":"A Unified Data Layer for Large-Scale Single-Cell, Spatial and Bulk Immunomics","text":"[!CAUTION] 🚧 construction. 🚧 Pretty much whole README either single-chain paired-chain data. Consider passing make_default_preprocessing(\"airr\") make_default_preprocessing(\"10x\") read_repertoires(..., preproc = <>, ...) convenient processing corresponding formats. Pass count_col read_repertoires(..., count_col = \"Counts\", ...) assign counts chains.","code":""},{"path":"https://immunomind.github.io/immundata/index.html","id":"single-cell-and-paired-chain--scrnaseq-scvdjseq-sctcrseq-scbcrseq","dir":"","previous_headings":"🧩 Use Cases","what":"Single-cell and paired-chain – scRNAseq, scVDJseq, scTCRseq, scBCRseq","title":"A Unified Data Layer for Large-Scale Single-Cell, Spatial and Bulk Immunomics","text":"[!CAUTION] 🚧 construction. 🚧 Make sure pass make_default_preprocessing(\"10x\"), locus_col barcode_col read paired-chain data. Drop locus_col want read single-chain data .","code":"library(Seurat)   sdata <- ...  # Load the Seurat data idata <- ...  # Load the corresponding AIRR data  # Get both GEX and metadata smeta <- data.frame(   barcode      = colnames(sdata),   cluster      = Idents(sdata),   gene_MS4A1   = FetchData(sdata, \"MS4A1\")[,1] )  idata <- annotate_barcodes(idata, smeta, annot_col = \"barcode\") library(AnnDataR)  adata <- ...  # Load the AnndataR data idata <- ...  # Load the corresponding AIRR data  ameta <- data.frame(   barcode  = adata$obs_names,   cluster  = adata$obs$cell_type,   gene_GCG = adata$X[, \"GCG\"] )  idata <- annotate_barcodes(idata, ameta, annot_col = \"barcode\")"},{"path":[]},{"path":[]},{"path":"https://immunomind.github.io/immundata/index.html","id":"integrate-into-your-package","dir":"","previous_headings":"🧠 Advanced Topics > Developers","what":"Integrate into your package","title":"A Unified Data Layer for Large-Scale Single-Cell, Spatial and Bulk Immunomics","text":"[!CAUTION] 🚧 construction. 🚧 immundata created mind mission replacing typical data frame-based formats, usually following AIRR-C file standard.","code":""},{"path":"https://immunomind.github.io/immundata/index.html","id":"extend-with-functions","dir":"","previous_headings":"🧠 Advanced Topics > Developers","what":"Extend with functions","title":"A Unified Data Layer for Large-Scale Single-Cell, Spatial and Bulk Immunomics","text":"[!CAUTION] 🚧 construction. 🚧 S3 methods etc.","code":""},{"path":"https://immunomind.github.io/immundata/index.html","id":"how-immundata-reads-the-data","dir":"","previous_headings":"🧠 Advanced Topics","what":"How immundata reads the data","title":"A Unified Data Layer for Large-Scale Single-Cell, Spatial and Bulk Immunomics","text":"design, immundata data-loading pipeline three steps, rather one giant function. promotes modularity, easier debugging, flexible usage: ensures metadata correct file paths, absolute relative. annotations.parquet (cell-level data, sample metadata, etc.) calls read_immundata() return fully instantiated ImmunData object uses newly created files disk source. helps two-fold: don’t lose data, allows immundata run optimized code necessary. need reopen data future R session, don’t redo entire pipeline. Just call read_immundata(path_to_immundata_folder) folder contains annotations.parquet. approach, never need re-parse raw AIRR files ’ve generated Parquet-based immundata format. split ? Modularity: something breaks, can debug whether ’s metadata parsing actual repertoire table creation. Reusability: straightforward share one folder two immundata files. Performance: data immundata format, can load future sessions constant time without merging parsing .","code":""},{"path":"https://immunomind.github.io/immundata/index.html","id":"custom-functions-for-analysis","dir":"","previous_headings":"🧠 Advanced Topics","what":"Custom functions for analysis","title":"A Unified Data Layer for Large-Scale Single-Cell, Spatial and Bulk Immunomics","text":"[!CAUTION] 🚧 construction. 🚧 Function supported duckdb - use dd$<function_name> Use SQL Run completely custom function","code":""},{"path":"https://immunomind.github.io/immundata/index.html","id":"change-ram-limits-to-accelerate-the-backend-computations","dir":"","previous_headings":"🧠 Advanced Topics","what":"Change RAM limits to accelerate the backend computations","title":"A Unified Data Layer for Large-Scale Single-Cell, Spatial and Bulk Immunomics","text":"can change RAM limits duckplyr.","code":""},{"path":"https://immunomind.github.io/immundata/index.html","id":"make-immundata-even-faster-with-data-engineering-tricks","dir":"","previous_headings":"🧠 Advanced Topics","what":"Make immundata even faster with data engineering tricks","title":"A Unified Data Layer for Large-Scale Single-Cell, Spatial and Bulk Immunomics","text":"can use hive partitioning accelerate analysis. Recommended columns locus, V gene segment, sequence length.","code":""},{"path":"https://immunomind.github.io/immundata/index.html","id":"save-your-intermediate-data-for-faster-computations-and-reproducibility","dir":"","previous_headings":"🧠 Advanced Topics","what":"Save your intermediate data for faster computations and reproducibility","title":"A Unified Data Layer for Large-Scale Single-Cell, Spatial and Bulk Immunomics","text":"Consider caching data disk heavy operations, distance computations.","code":""},{"path":[]},{"path":"https://immunomind.github.io/immundata/index.html","id":"citation","dir":"","previous_headings":"🏷 About","what":"Citation","title":"A Unified Data Layer for Large-Scale Single-Cell, Spatial and Bulk Immunomics","text":"… coming soon …","code":""},{"path":"https://immunomind.github.io/immundata/index.html","id":"license","dir":"","previous_headings":"🏷 About","what":"License","title":"A Unified Data Layer for Large-Scale Single-Cell, Spatial and Bulk Immunomics","text":"package freely distributed Apache-2.0 license. can read .","code":""},{"path":"https://immunomind.github.io/immundata/index.html","id":"author-and-contributors","dir":"","previous_headings":"🏷 About","what":"Author and contributors","title":"A Unified Data Layer for Large-Scale Single-Cell, Spatial and Bulk Immunomics","text":"Vadim . Nazarov – main author developer Vasily Tsvetkov … come …","code":""},{"path":"https://immunomind.github.io/immundata/index.html","id":"commercial-usage","dir":"","previous_headings":"🏷 About","what":"Commercial usage","title":"A Unified Data Layer for Large-Scale Single-Cell, Spatial and Bulk Immunomics","text":"immundata free use commercial usage per Apache-2.0 license. However, corporate users get prioritized support immundata- AIRR-related issues. priority open-source tool immundata open-source science. looking prioritized support setting data pipelines, consider contacting Vadim Nazarov commercial consulting / support options / workshops training sessions / designing data platforms machine learning systems multi-omics / anything related.","code":""},{"path":"https://immunomind.github.io/immundata/index.html","id":"id_-faq","dir":"","previous_headings":"","what":"🤔 FAQ","title":"A Unified Data Layer for Large-Scale Single-Cell, Spatial and Bulk Immunomics","text":"Q: function names ImmunData fields long? want write idata$rec instead idata$receptors. : Two major reasons – improving code readability motivation leverage autocomplete tools. Please consider using tab leveraging autocomplete. accelerates things x10-20. Q: immundata works hood, simpler terms? : Picture three-layer sandwich: Arrow files disk hold raw tables column-compressed Parquet. DuckDB -process SQL engine can query files without loading fully RAM. duckplyr glues dplyr verbs (filter, mutate, summarise, …) DuckDB SQL, R code looks exactly like tidyverse pipeline heavy lifting happens C++. call read_repertoires(), immundata writes Arrow parts, registers DuckDB, returns duckplyr table. Every later verb lazily translated SQL; nothing materialised step truly needs physical data (e.g. plot algorithm exists R). References Arrow R – columnar file format DuckDB – embedded analytical database duckplyr – API/implementation details Q: need create Parquet files receptors annotations? : intermediate files, optimized future data operations, working significantly accelerates immundata. post benchmark soon. Q: immundata support AIRR standard?! : short answer single, stable schema beats zoo drifting ones. practical answer immundata allows optionality – can provide column names barcodes, etc. long answer amount investments required development, also continued support parsers different formats, astonishing. developed parsers 10+ formats tcR / immunarch packages. much prefer upstream tool developers change format minor version, breaking pretty much downstream pipelines causing sorts pain end users tools developers – mind , without bearing responsibility least notify, ideally fix broken formats introduced. time Wild West . AIRR community outstanding job creating standard. Please urge creators favourite tools fellow developers use format superset, like immundata . immundata explicitly support formats. practical stance communication crucial values, put immundata part broader ecosystem AIRR tools. domain already complex, need work together make complexity manageable. healthy ecosystem complex ecosystem. Q: complex? need use dplyr instead plain R? : short answer : faster computations; code, easy maintain support humans; better data skills thanks thinking immutable transformations, cases don’t really need complex transformations, can optimize 95% AIRR data operations behind scenes. Q: use dplyr operations duckplyr doesn’t support yet? : Let’s consider several use cases. Case 0. missing group_by dplyr. Use summarise(.= ???, ...). Case 1. data can fit RAM. Call collect use dplyr. Case 2. data won’t fit RAM must run heavy operation rows. can rewrite functions SQL. can break supported pieces (e.g. pre-filter, pre-aggregate) DuckDB can stream, write intermediate Parquet compute_parquet(), loop chunks, collect , run analysis. Case 3. data won’t fit RAM, running intensive computations, open working smaller dataset first. Filter via slice_head(n=...), iterate code works, run pipeline full dataset. Q: filter non-productive receptors. explore ? : filter non-productive receptors preprocess read_repertoires(). Q: immundata column names receptors repertoires? just use AIRR format - repertoire_id etc.? : power immundata lies fast re-aggregation data, allows work whatever define repertoire fly via agg_repertoires. Hence use superset AIRR format, totally acceptable per documentation. Q: following error: “Error compute_parquet() […]: ! ?* : means repertoire files different schemas, .e., different column names. two options. Option 1: Check data fix schema. Explore reason data different schemas. Remove wrong files. Change column names. try . Option 2: know , pass argument enforce_schema = FALSE read_repertoires. resultant table NAs place missing values. don’t use without considering first option. Broken schema usually means issues data processed upstream. Q: immundata verbose, ’m tired messages. turn ? : Run following code options(rlib_message_verbosity = \"quiet\") beginning R session turn messages. Q: don’t want use pak, can use good old install.packages devtools? : Nothing stop , eh? welcome, ’m responsible something won’t work due issues dependencies: Q: counts receptors available aggregation? : Counts proportions properties receptor inside specific repertoire. receptor seen two samples counted twice – per repertoire. receptors repertoires defined, “count” ambiguous. ’s numbers appear agg_receptors() agg_repertoires() locked definitions .","code":"# CRAN release install.packages(\"immundata\")  # GitHub release install.packages(c(\"devtools\", \"pkgload\")) devtools::install_github(\"immunomind/immundata\") devtools::reload(pkgload::inst(\"immundata\"))  # Development version devtools::install_github(\"immunomind/immundata\", ref = \"dev\") devtools::reload(pkgload::inst(\"immundata\"))"},{"path":"https://immunomind.github.io/immundata/reference/IMD_GLOBALS.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal Immundata Global Configuration — IMD_GLOBALS","title":"Internal Immundata Global Configuration — IMD_GLOBALS","text":"IMD_GLOBALS internal list stores globally used constants across Immundata system. intended direct use package users, rather ensure consistency schema field names, default file names, internal error messages.","code":""},{"path":"https://immunomind.github.io/immundata/reference/IMD_GLOBALS.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal Immundata Global Configuration — IMD_GLOBALS","text":"","code":"IMD_GLOBALS"},{"path":"https://immunomind.github.io/immundata/reference/IMD_GLOBALS.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Internal Immundata Global Configuration — IMD_GLOBALS","text":"object class list length 6.","code":""},{"path":"https://immunomind.github.io/immundata/reference/IMD_GLOBALS.html","id":"components","dir":"Reference","previous_headings":"","what":"Components","title":"Internal Immundata Global Configuration — IMD_GLOBALS","text":"messages: Named list default messages error texts (e.g., \"NotImpl\"). schema: Standardized column names internal schema usage. include: cell: Column name cell barcode IDs. receptor: Column name receptor unique identifiers. repertoire: Column name repertoire group IDs. metadata_filename: Column name metadata files (internal). count: Column name receptor count per group. filename: Original column name used user metadata. files: Default file names used store structured Immundata: receptors: File name receptor-level data (receptors.parquet). annotations: File name annotation-level data (annotations.parquet).","code":""},{"path":"https://immunomind.github.io/immundata/reference/ImmunData.html","id":null,"dir":"Reference","previous_headings":"","what":"ImmunData: A Unified Structure for Immune Receptor Repertoire Data — ImmunData","title":"ImmunData: A Unified Structure for Immune Receptor Repertoire Data — ImmunData","text":"ImmunData abstract R6 class managing transforming immune receptor repertoire data. supports flexible backends (e.g., Arrow, DuckDB, dbplyr) lazy evaluation, provides tools filtering, aggregation, receptor--repertoire mapping.","code":""},{"path":[]},{"path":"https://immunomind.github.io/immundata/reference/ImmunData.html","id":"public-fields","dir":"Reference","previous_headings":"","what":"Public fields","title":"ImmunData: A Unified Structure for Immune Receptor Repertoire Data — ImmunData","text":"schema_receptor named list describing interpret receptor-level data. includes fields used aggregation (e.g., CDR3, V_gene, J_gene), optionally unique identifiers receptor row. Used ensure consistency across processing steps. schema_repertoire named list defining barcodes annotations grouped repertoires. may include sample-level metadata (e.g., sample_id, donor_id) used define unique repertoires.","code":""},{"path":"https://immunomind.github.io/immundata/reference/ImmunData.html","id":"active-bindings","dir":"Reference","previous_headings":"","what":"Active bindings","title":"ImmunData: A Unified Structure for Immune Receptor Repertoire Data — ImmunData","text":"receptors Accessor dynamically-created table receptors. annotations Accessor annotation-level table (.annotations). repertoires Get vector repertoire names data aggregation agg_repertoires()","code":""},{"path":[]},{"path":"https://immunomind.github.io/immundata/reference/ImmunData.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"ImmunData: A Unified Structure for Immune Receptor Repertoire Data — ImmunData","text":"ImmunData$new() ImmunData$clone()","code":""},{"path":"https://immunomind.github.io/immundata/reference/ImmunData.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"ImmunData: A Unified Structure for Immune Receptor Repertoire Data — ImmunData","text":"Creates new ImmunData object. constructor expects receptor-level barcode-level data, along receptor schema defining aggregation identity fields.","code":""},{"path":"https://immunomind.github.io/immundata/reference/ImmunData.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ImmunData: A Unified Structure for Immune Receptor Repertoire Data — ImmunData","text":"","code":"ImmunData$new(schema, annotations, repertoires = NULL)"},{"path":"https://immunomind.github.io/immundata/reference/ImmunData.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ImmunData: A Unified Structure for Immune Receptor Repertoire Data — ImmunData","text":"schema character vector specifying receptor schema (e.g., aggregate fields, ID columns). annotations cell/barcode-level dataset mapping barcodes receptor rows. repertoires repertoire table, created inside body agg_repertoires.","code":""},{"path":"https://immunomind.github.io/immundata/reference/ImmunData.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"ImmunData: A Unified Structure for Immune Receptor Repertoire Data — ImmunData","text":"objects class cloneable method.","code":""},{"path":"https://immunomind.github.io/immundata/reference/ImmunData.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"ImmunData: A Unified Structure for Immune Receptor Repertoire Data — ImmunData","text":"","code":"ImmunData$clone(deep = FALSE)"},{"path":"https://immunomind.github.io/immundata/reference/ImmunData.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"ImmunData: A Unified Structure for Immune Receptor Repertoire Data — ImmunData","text":"deep Whether make deep clone.","code":""},{"path":"https://immunomind.github.io/immundata/reference/agg_receptors.html","id":null,"dir":"Reference","previous_headings":"","what":"Aggregates AIRR data into receptors — agg_receptors","title":"Aggregates AIRR data into receptors — agg_receptors","text":"Processes table immune receptor sequences (chains clonotypes) identify unique receptors based specified schema. assigns unique identifier (imd_receptor_id) distinct receptor signature returns annotated table linking original sequence data receptor IDs. function core component used within read_repertoires() handles different input data structures: Simple tables (counts, cell IDs). Bulk sequencing data (using count column). Single-cell data (using barcode/cell ID column). single-cell data, can perform chain pairing schema specifies multiple chains (e.g., TRA TRB).","code":""},{"path":"https://immunomind.github.io/immundata/reference/agg_receptors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Aggregates AIRR data into receptors — agg_receptors","text":"","code":"agg_receptors(   dataset,   schema,   barcode_col = NULL,   count_col = NULL,   locus_col = NULL,   umi_col = NULL )"},{"path":"https://immunomind.github.io/immundata/reference/agg_receptors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Aggregates AIRR data into receptors — agg_receptors","text":"dataset data frame duckplyr_df containing sequence/clonotype data. Must include columns specified schema potentially barcode_col, count_col, locus_col, umi_col. idata$annotations. schema Defines unique receptor identified. Can : character vector column names representing receptor features (e.g., c(\"v_call\", \"j_call\", \"junction_aa\")). list created make_receptor_schema(), specifying features (character vector) optionally chains (character vector locus names like \"TRA\", \"TRB\", \"IGH\", \"IGK\", \"IGL\", max length 2). Specifying chains triggers filtering locus enables pairing logic two chains given. barcode_col Character(1). name column containing cell identifiers (barcodes). Required single-cell processing chain pairing. Default: NULL. count_col Character(1). name column containing counts (e.g., UMI counts bulk, clonotype frequency). Used bulk data processing. Default: NULL. specified barcode_col set. locus_col Character(1). name column specifying chain locus (e.g., \"TRA\", \"TRB\"). Required schema includes chains filtering pairing. Default: NULL. umi_col Character(1). name column containing UMI counts. Required paired-chain single-cell data (length(schema$chains) == 2). Used select abundant chain per locus within cell multiple chains locus present. Default: NULL.","code":""},{"path":"https://immunomind.github.io/immundata/reference/agg_receptors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Aggregates AIRR data into receptors — agg_receptors","text":"duckplyr_df (data frame) representing annotated sequences. table links original sequence record (chain) defined receptor includes standardized columns: imd_receptor_id: Integer ID unique distinct receptor signature. imd_barcode_id: Integer ID unique cell/barcode (row barcode). imd_chain_id: Integer ID unique input row (chain). imd_chain_count: Integer count associated chain (1 SC/simple, count_col bulk). output typically assigned $annotations field ImmunData object.","code":""},{"path":"https://immunomind.github.io/immundata/reference/agg_receptors.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Aggregates AIRR data into receptors — agg_receptors","text":"function performs following main steps: Validation: Checks inputs, schema validity, existence required columns. Schema Parsing: Determines receptor features target chains schema. Locus Filtering: schema$chains provided, filters dataset include rows matching specified locus/loci. Processing Logic (based barcode_col count_col): Simple Table/Bulk (Barcodes): Assigns unique internal barcode/chain IDs. Identifies unique receptors based schema$features. Calculates imd_chain_count (1 simple table, count_col bulk). Single-Cell (Barcodes Provided): Uses barcode_col imd_barcode_id. Single Chain: (length(schema$chains) <= 1). Identifies unique receptors based schema$features. imd_chain_count 1. Paired Chain: (length(schema$chains) == 2). Requires locus_col umi_col. Filters chains within cell/locus group based max umi_col. Creates paired receptors joining two specified loci cell based schema$features . Assigns unique imd_receptor_id pair. imd_chain_count 1 (representing chain record). Output: Returns annotated data frame containing original columns plus internal identifiers (imd_receptor_id, imd_barcode_id, imd_chain_id) counts (imd_chain_count). Internal column names typically managed immundata:::imd_schema().","code":""},{"path":[]},{"path":"https://immunomind.github.io/immundata/reference/agg_repertoires.html","id":null,"dir":"Reference","previous_headings":"","what":"Aggregate AIRR data into repertoires — agg_repertoires","title":"Aggregate AIRR data into repertoires — agg_repertoires","text":"Groups annotation table ImmunData object user-specified columns define distinct repertoires (e.g., based sample, donor, time point). calculates summary statistics per-repertoire per-receptor within repertoire. Calculated per repertoire: n_barcodes: Total number unique cells/barcodes within repertoire (sum imd_chain_count, effectively summing unique cells input SC, total counts input bulk). n_receptors: Number unique receptors (imd_receptor_id) found within repertoire. Calculated per annotation row (receptor within repertoire context): imd_count: Total count specific receptor (imd_receptor_id) within specific repertoire belongs row (sum relevant imd_chain_count). imd_proportion: proportion repertoire's total n_barcodes accounted specific receptor (imd_count / n_barcodes). n_repertoires: total number distinct repertoires (across entire dataset) specific receptor (imd_receptor_id) appears. statistics added annotation table, summary table stored $repertoires slot returned object.","code":""},{"path":"https://immunomind.github.io/immundata/reference/agg_repertoires.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Aggregate AIRR data into repertoires — agg_repertoires","text":"","code":"agg_repertoires(idata, schema = \"repertoire_id\")"},{"path":"https://immunomind.github.io/immundata/reference/agg_repertoires.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Aggregate AIRR data into repertoires — agg_repertoires","text":"idata ImmunData object, typically output read_repertoires() read_immundata(). Must contain $annotations table columns specified schema internal columns like imd_receptor_id imd_chain_count. schema Character vector. Column name(s) idata$annotations define unique repertoire. example, c(\"SampleID\") c(\"DonorID\", \"TimePoint\"). Columns must exist idata$annotations. Default: \"repertoire_id\" (assumes column exists).","code":""},{"path":"https://immunomind.github.io/immundata/reference/agg_repertoires.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Aggregate AIRR data into repertoires — agg_repertoires","text":"new ImmunData object. $annotations table includes added columns (imd_repertoire_id, imd_count, imd_proportion, n_repertoires). $repertoires slot contains summary table linking schema columns imd_repertoire_id, n_barcodes, n_receptors.","code":""},{"path":"https://immunomind.github.io/immundata/reference/agg_repertoires.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Aggregate AIRR data into repertoires — agg_repertoires","text":"function operates idata$annotations table: Validation: Checks idata existence schema columns. Removes pre-existing repertoire summary columns prevent duplication. Repertoire Definition: Groups annotations schema columns. Calculates total counts (n_barcodes) per group. Assigns unique integer imd_repertoire_id distinct repertoire group. forms initial repertoires_table. Receptor Counts & Proportion: Calculates sum imd_chain_count receptor within repertoire (imd_count). Calculates proportion (imd_proportion) receptor within repertoire. Repertoire & Receptor Stats: Counts unique receptors per repertoire (n_receptors, added repertoires_table). Counts number distinct repertoires unique receptor appears (n_repertoires). Join Results: Joins calculated imd_count, imd_proportion, n_repertoires back annotation table based repertoire columns imd_receptor_id. Return New Object: Creates returns new ImmunData object containing updated $annotations table (added statistics) $repertoires slot populated repertoires_table (containing schema columns, imd_repertoire_id, n_barcodes, n_receptors). original idata object remains unmodified. Internal column names typically managed immundata:::imd_schema().","code":""},{"path":[]},{"path":"https://immunomind.github.io/immundata/reference/agg_repertoires.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Aggregate AIRR data into repertoires — agg_repertoires","text":"","code":"if (FALSE) { # \\dontrun{ # Assume 'idata_raw' is an ImmunData object loaded via read_repertoires # but *without* providing 'repertoire_schema' initially. # It has $annotations but $repertoires is likely NULL or empty. # Assume idata_raw$annotations has columns \"SampleID\" and \"TimePoint\".  # Define repertoires based on SampleID and TimePoint idata_aggregated <- agg_repertoires(idata_raw, schema = c(\"SampleID\", \"TimePoint\"))  # Explore the results print(idata_aggregated) print(idata_aggregated$repertoires) print(head(idata_aggregated$annotations)) # Note the new columns } # }"},{"path":"https://immunomind.github.io/immundata/reference/annotate_immundata.html","id":null,"dir":"Reference","previous_headings":"","what":"Annotate ImmunData object — annotate_immundata","title":"Annotate ImmunData object — annotate_immundata","text":"Joins additional annotation data annotations slot ImmunData object. function allows add extra information repertoire data joining dataframe annotations based specified columns. supports joining one columns.","code":""},{"path":"https://immunomind.github.io/immundata/reference/annotate_immundata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Annotate ImmunData object — annotate_immundata","text":"","code":"annotate_immundata(   idata,   annotations,   by,   keep_repertoires = TRUE,   remove_limit = FALSE )  annotate(idata, annotations, by, keep_repertoires = TRUE, remove_limit = FALSE)  annotate_receptors(   idata,   annotations,   annot_col = imd_schema(\"receptor\"),   keep_repertoires = TRUE,   remove_limit = FALSE )  annotate_barcodes(   idata,   annotations,   annot_col = \"<rownames>\",   keep_repertoires = TRUE,   remove_limit = FALSE )  annotate_chains(   idata,   annotations,   annot_col = imd_schema(\"chain\"),   keep_repertoires = TRUE,   remove_limit = FALSE )"},{"path":"https://immunomind.github.io/immundata/reference/annotate_immundata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Annotate ImmunData object — annotate_immundata","text":"idata ImmunData R6 object containing repertoire annotation data. annotations data frame containing annotations joined. named character vector specifying columns join . names vector column names idata$annotations values corresponding column names annotations data frame. keep_repertoires Logical. TRUE (default) ImmunData object contains repertoire data (idata$schema_repertoire NULL), repertoires re-aggregated joining annotations. Set FALSE want re-aggregate repertoires immediately. remove_limit Logical. FALSE (default), warning issued annotations data frame 100 columns, suggesting potential performance issues. Set TRUE disable warning allow joining annotations arbitrary number columns. Use caution, joining wide dataframes can memory-intensive slow. annot_col character vector specifying column receptor, barcode chain identifiers annotate corresponding receptors, barode chains idata.","code":""},{"path":"https://immunomind.github.io/immundata/reference/annotate_immundata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Annotate ImmunData object — annotate_immundata","text":"new ImmunData object annotations joined annotations slot.","code":""},{"path":"https://immunomind.github.io/immundata/reference/annotate_immundata.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Annotate ImmunData object — annotate_immundata","text":"function performs left join operation, keeping rows idata$annotations adding matching columns annotations data frame. multiple matches annotations row idata$annotations, combinations returned, potentially increasing number rows resulting annotations table. function uses checkmate validate input types structure. check performed ensure columns specified exist idata$annotations annotations data frame. annotations data frame converted duckdb tibble internally efficient joining, especially large datasets.","code":""},{"path":"https://immunomind.github.io/immundata/reference/annotate_immundata.html","id":"warning","dir":"Reference","previous_headings":"","what":"Warning","title":"Annotate ImmunData object — annotate_immundata","text":"default (remove_limit = FALSE), joining annotations data frame 100 columns trigger warning. safeguard prevent accidental joining wide data (e.g., gene expression data) lead performance degradation crashes. understand risks intend join wide data frame, set remove_limit = TRUE.","code":""},{"path":"https://immunomind.github.io/immundata/reference/annotate_immundata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Annotate ImmunData object — annotate_immundata","text":"","code":"if (FALSE) { # \\dontrun{ # Assuming 'my_immun_data' is an ImmunData object and 'sample_info' is a data frame # with a column 'sample_id' matching 'sample' in my_immun_data$annotations # and additional columns like 'treatment' and 'disease_status'.  sample_info <- data.frame(   sample_id = c(\"sample1\", \"sample2\", \"sample3\", \"sample4\"),   treatment = c(\"Treatment A\", \"Treatment B\", \"Treatment A\", \"Treatment C\"),   disease_status = c(\"Healthy\", \"Disease\", \"Healthy\", \"Disease\"),   stringsAsFactors = FALSE # Important to keep characters as characters )  # Join sample information using the 'sample' column my_immun_data_annotated <- annotate(   idata = my_immun_data,   annotations = sample_info,   by = c(\"sample\" = \"sample_id\") )  # New sample_info  # Join data by multiple columns, e.g., 'sample' and 'barcode' # Assuming 'cell_annotations' is a data frame with 'sample_barcode' and 'cell_type' my_immun_data_cell_annotated <- annotate(   idata = my_immun_data,   annotations = cell_annotations,   by = c(\"sample\" = \"sample\", \"barcode\" = \"sample_barcode\") )  # Join a wide dataframe, suppressing the column limit warning # Assuming 'gene_expression' is a data frame with 'barcode' and many gene columns my_immun_data_gene_expression <- annotate(   idata = my_immun_data,   annotations = gene_expression,   by = c(\"barcode\" = \"barcode\"),   remove_limit = TRUE ) } # }"},{"path":"https://immunomind.github.io/immundata/reference/count.ImmunData.html","id":null,"dir":"Reference","previous_headings":"","what":"Count the number of chains in ImmunData — count.ImmunData","title":"Count the number of chains in ImmunData — count.ImmunData","text":"Count number chains ImmunData","code":""},{"path":"https://immunomind.github.io/immundata/reference/count.ImmunData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Count the number of chains in ImmunData — count.ImmunData","text":"","code":"# S3 method for class 'ImmunData' count(x, ..., wt = NULL, sort = FALSE, name = NULL)"},{"path":"https://immunomind.github.io/immundata/reference/count.ImmunData.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Count the number of chains in ImmunData — count.ImmunData","text":"x ImmunData object. ... used. wt used. sort used. name used.","code":""},{"path":"https://immunomind.github.io/immundata/reference/filter_immundata.html","id":null,"dir":"Reference","previous_headings":"","what":"Filter ImmunData by receptor features, barcodes or any annotations — filter_immundata","title":"Filter ImmunData by receptor features, barcodes or any annotations — filter_immundata","text":"Provides flexible filtering options ImmunData object. filter() main function, allowing filtering based receptor features (e.g., CDR3 sequence) using various matching methods (exact, regex, fuzzy) /standard dplyr-style filtering annotation columns. filter_barcodes() convenience function filter specific cell barcodes. filter_receptors() convenience function filter specific receptor identifiers.","code":""},{"path":"https://immunomind.github.io/immundata/reference/filter_immundata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filter ImmunData by receptor features, barcodes or any annotations — filter_immundata","text":"","code":"filter_immundata(idata, ..., seq_options = NULL, keep_repertoires = TRUE)  # S3 method for class 'ImmunData' filter(   .data,   ...,   .by = NULL,   .preserve = FALSE,   seq_options = NULL,   keep_repertoires = TRUE )  filter_barcodes(idata, barcodes, keep_repertoires = TRUE)  filter_receptors(idata, receptors, keep_repertoires = TRUE)"},{"path":"https://immunomind.github.io/immundata/reference/filter_immundata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filter ImmunData by receptor features, barcodes or any annotations — filter_immundata","text":"idata, .data ImmunData object. ... filter, regular dplyr-style filtering expressions (e.g., V_gene == \"IGHV1-1\", chain == \"IGH\") applied $annotations table sequence filtering. Ignored filter_barcodes filter_receptors. seq_options filter, optional named list specifying sequence-based filtering options. Use make_seq_options() convenient creation. list can contain: query_col (Character scalar): name column $annotations containing sequences compare (e.g., \"CDR3_aa\", \"FR1_nt\"). patterns (Character vector): vector sequences regular expressions match query_col. method (Character scalar): matching method. One \"exact\", \"regex\", \"lev\" (Levenshtein distance), \"hamm\" (Hamming distance). Defaults typically handled make_seq_options. max_dist (Numeric scalar): fuzzy methods (\"lev\", \"hamm\"), maximum allowed distance. Rows distance <= max_dist kept. Defaults typically handled make_seq_options. name_type (Character scalar): Determines column names intermediate distance calculations applicable (\"index\" \"pattern\"). Passed internal annotation functions. Defaults typically handled make_seq_options. seq_options NULL (default), sequence-based filtering performed. keep_repertoires Logical scalar. TRUE (default) input idata repertoire information (idata$schema_repertoire NULL), repertoire summaries recalculated based filtered data using agg_repertoires(). FALSE, repertoire schema exists, returned ImmunData object contain repertoire summaries ($repertoires NULL). .used. .preserve used. barcodes filter_barcodes, vector cell identifiers (barcodes) keep. Can character, integer, numeric. receptors filter_receptors, vector receptor identifiers keep. Can character, integer, numeric.","code":""},{"path":"https://immunomind.github.io/immundata/reference/filter_immundata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filter ImmunData by receptor features, barcodes or any annotations — filter_immundata","text":"new ImmunData object containing filtered annotations (potentially recalculated repertoire summaries). schema remains .","code":""},{"path":"https://immunomind.github.io/immundata/reference/filter_immundata.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Filter ImmunData by receptor features, barcodes or any annotations — filter_immundata","text":"filter: User-provided dplyr-style filters (...) applied sequence-based filtering defined seq_options. Sequence filtering compares values query_col annotations table provided patterns. Supported sequence matching methods : \"exact\": Keeps rows query_col exactly matches patterns. \"regex\": Keeps rows query_col matches regular expressions patterns. \"lev\" (Levenshtein distance): Keeps rows edit distance query_col pattern less equal max_dist. \"hamm\" (Hamming distance): Keeps rows Hamming distance (equal length strings) query_col pattern less equal max_dist. filtering operations act $annotations table. new ImmunData object created containing rows (corresponding receptors) pass filter(s). keep_repertoires = TRUE (repertoire data exists input), repertoire-level summaries ($repertoires table) recalculated based filtered annotations. Otherwise, $repertoires table output NULL. filter_barcodes filter_receptors: functions provide simpler interface common filtering tasks based cell barcodes receptor IDs, respectively. use efficient semi_join operations internally.","code":""},{"path":[]},{"path":"https://immunomind.github.io/immundata/reference/filter_immundata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Filter ImmunData by receptor features, barcodes or any annotations — filter_immundata","text":"","code":"# Basic setup (assuming idata_test is a valid ImmunData object) # print(idata_test)  # --- filter examples --- if (FALSE) { # \\dontrun{ # Example 1: dplyr-style filtering on annotations filtered_heavy <- filter(idata_test, chain == \"IGH\") print(filtered_heavy)  # Example 2: Exact sequence matching on CDR3 amino acid sequence cdr3_patterns <- c(\"CARGLGLVFYGMDVW\", \"CARDNRGAVAGVFGEAFYW\") seq_opts_exact <- make_seq_options(query_col = \"CDR3_aa\", patterns = cdr3_patterns) filtered_exact_cdr3 <- filter(idata_test, seq_options = seq_opts_exact) print(filtered_exact_cdr3)  # Example 3: Combining dplyr-style and fuzzy sequence matching (Levenshtein) seq_opts_lev <- make_seq_options(   query_col = \"CDR3_aa\",   patterns = \"CARGLGLVFYGMDVW\",   method = \"lev\",   max_dist = 1 ) filtered_combined <- filter(idata_test,   chain == \"IGH\",   C_gene == \"IGHG1\",   seq_options = seq_opts_lev ) print(filtered_combined)  # Example 4: Regex matching on V gene v_gene_pattern <- \"^IGHV[13]-\" # Keep only IGHV1 or IGHV3 families seq_opts_regex <- make_seq_options(   query_col = \"V_gene\",   patterns = v_gene_pattern,   method = \"regex\" ) filtered_regex_v <- filter(idata_test, seq_options = seq_opts_regex) print(filtered_regex_v)  # Example 5: Filtering without recalculating repertoires filtered_no_rep <- filter(idata_test, chain == \"IGK\", keep_repertoires = FALSE) print(filtered_no_rep) # $repertoires should be NULL } # }  # --- filter_barcodes example --- if (FALSE) { # \\dontrun{ # Assuming 'cell1_barcode' and 'cell5_barcode' exist in idata_test$annotations$cell_id specific_barcodes <- c(\"cell1_barcode\", \"cell5_barcode\") filtered_cells <- filter_barcodes(idata_test, barcodes = specific_barcodes) print(filtered_cells) } # }  # --- filter_receptors example --- if (FALSE) { # \\dontrun{ # Assuming receptor IDs 101 and 205 exist in idata_test$annotations$receptor_id specific_receptors <- c(101, 205) # Or character IDs if applicable filtered_recs <- filter_receptors(idata_test, receptors = specific_receptors) print(filtered_recs) } # }"},{"path":"https://immunomind.github.io/immundata/reference/from_immunarch.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert an immunarch Object into an ImmunData Dataset — from_immunarch","title":"Convert an immunarch Object into an ImmunData Dataset — from_immunarch","text":"from_immunarch() function takes immunarch object (returned immunarch::repLoad()), writes repertoire TSV file added filename column specified folder, imports files ImmunData object via read_repertoires().","code":""},{"path":"https://immunomind.github.io/immundata/reference/from_immunarch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert an immunarch Object into an ImmunData Dataset — from_immunarch","text":"","code":"from_immunarch(   imm,   output_folder,   schema = c(\"CDR3.aa\", \"V.name\"),   temp_folder = file.path(tempdir(), \"temp_folder\") )"},{"path":"https://immunomind.github.io/immundata/reference/from_immunarch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert an immunarch Object into an ImmunData Dataset — from_immunarch","text":"imm list returned immunarch::repLoad(), typically containing: data: named list data.frames, one per repertoire. meta: (optional) data.frame sample metadata. output_folder Path output directory resulting ImmunData Parquet files stored. directory created already exist. schema Character vector column names together define unique receptors (example, c(\"CDR3.aa\", \"V.name\", \"J.name\")). temp_folder Path directory intermediate TSV files written. Defaults file.path(tempdir(), \"temp_folder\").","code":""},{"path":"https://immunomind.github.io/immundata/reference/from_immunarch.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert an immunarch Object into an ImmunData Dataset — from_immunarch","text":"ImmunData object containing repertoires input immunarch object, data saved output_folder.","code":""},{"path":[]},{"path":"https://immunomind.github.io/immundata/reference/from_immunarch.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert an immunarch Object into an ImmunData Dataset — from_immunarch","text":"","code":"if (FALSE) { # \\dontrun{ imm <- immunarch::repLoad(\"/path/to/your/files\") idata <- from_immunarch(imm,   schema = c(\"CDR3.aa\", \"V.name\"),   temp_folder = tempdir(),   output_folder = \"/path/to/immundata_out\" ) } # }"},{"path":"https://immunomind.github.io/immundata/reference/get_test_idata.html","id":null,"dir":"Reference","previous_headings":"","what":"Get test datasets from immundata — get_test_idata","title":"Get test datasets from immundata — get_test_idata","text":"Get test datasets immundata","code":""},{"path":"https://immunomind.github.io/immundata/reference/get_test_idata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get test datasets from immundata — get_test_idata","text":"","code":"get_test_idata()"},{"path":"https://immunomind.github.io/immundata/reference/get_test_immundata.html","id":null,"dir":"Reference","previous_headings":"","what":"Get test datasets from immundata — get_test_immundata","title":"Get test datasets from immundata — get_test_immundata","text":"Get test datasets immundata","code":""},{"path":"https://immunomind.github.io/immundata/reference/get_test_immundata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get test datasets from immundata — get_test_immundata","text":"","code":"get_test_immundata()"},{"path":"https://immunomind.github.io/immundata/reference/imd_schema.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Immundata internal schema field names — imd_schema","title":"Get Immundata internal schema field names — imd_schema","text":"Returns standardized field names used across Immundata objects processing functions, defined IMD_GLOBALS$schema. include column names cell ids barcodes, receptors, repertoires, related metadata.","code":""},{"path":"https://immunomind.github.io/immundata/reference/imd_schema.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Immundata internal schema field names — imd_schema","text":"","code":"imd_schema(key = NULL)  imd_schema_sym(key = NULL)  imd_meta_schema()  imd_files()  imd_rename_cols(format = \"default\")  imd_drop_cols(format = \"airr\")  imd_repertoire_schema(format = \"airr\")  imd_receptor_features(schema)  imd_receptor_chains(schema)"},{"path":"https://immunomind.github.io/immundata/reference/imd_schema.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Immundata internal schema field names — imd_schema","text":"key Character field return. format Character format load - \"airr\" \"10x\". schema Receptor schema make_receptor_schema().","code":""},{"path":"https://immunomind.github.io/immundata/reference/immundata-package.html","id":null,"dir":"Reference","previous_headings":"","what":"immundata: A Unified Data Layer for Large-Scale Single-Cell, Spatial and Bulk Immunomics — immundata-package","title":"immundata: A Unified Data Layer for Large-Scale Single-Cell, Spatial and Bulk Immunomics — immundata-package","text":"Provides unified data layer single-cell, spatial bulk T-cell B-cell immune receptor repertoire data. Think AnnData SeuratObject, AIRR data.","code":""},{"path":[]},{"path":"https://immunomind.github.io/immundata/reference/immundata-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"immundata: A Unified Data Layer for Large-Scale Single-Cell, Spatial and Bulk Immunomics — immundata-package","text":"Maintainer: Vadim . Nazarov support@immunomind.com (ORCID)","code":""},{"path":"https://immunomind.github.io/immundata/reference/make_receptor_schema.html","id":null,"dir":"Reference","previous_headings":"","what":"Create or validate a receptor schema object — make_receptor_schema","title":"Create or validate a receptor schema object — make_receptor_schema","text":"Helper functions defining validating schema used agg_receptors() identify unique receptors. make_receptor_schema() creates schema list object. assert_receptor_schema() checks object valid schema list throws error . test_receptor_schema() checks object valid schema list character vector (agg_receptors can also accept) returns TRUE FALSE.","code":""},{"path":"https://immunomind.github.io/immundata/reference/make_receptor_schema.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create or validate a receptor schema object — make_receptor_schema","text":"","code":"make_receptor_schema(features, chains = NULL)  assert_receptor_schema(schema)  test_receptor_schema(schema)"},{"path":"https://immunomind.github.io/immundata/reference/make_receptor_schema.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create or validate a receptor schema object — make_receptor_schema","text":"features Character vector. Column names defining features single receptor chain (e.g., V gene, J gene, CDR3 sequence). chains Optional character vector (max length 2). Locus names (e.g., \"TRA\", \"TRB\") filter pair. NULL length 1, filtering occurs. length 2, pairing logic enabled agg_receptors(). Default: NULL. schema object test assert valid schema. Can list created make_receptor_schema character vector (test_receptor_schema).","code":""},{"path":"https://immunomind.github.io/immundata/reference/make_receptor_schema.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create or validate a receptor schema object — make_receptor_schema","text":"make_receptor_schema returns list elements features chains. assert_receptor_schema returns TRUE invisibly valid, stops execution. test_receptor_schema returns TRUE FALSE.","code":""},{"path":"https://immunomind.github.io/immundata/reference/make_seq_options.html","id":null,"dir":"Reference","previous_headings":"","what":"Build a seq_options list for sequence‑based receptor filtering — make_seq_options","title":"Build a seq_options list for sequence‑based receptor filtering — make_seq_options","text":"convenience wrapper validates common arguments filter_receptors() returns required list form.","code":""},{"path":"https://immunomind.github.io/immundata/reference/make_seq_options.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build a seq_options list for sequence‑based receptor filtering — make_seq_options","text":"","code":"make_seq_options(   query_col,   patterns,   method = c(\"exact\", \"lev\", \"hamm\", \"regex\"),   max_dist = NA,   name_type = c(\"index\", \"pattern\") )"},{"path":"https://immunomind.github.io/immundata/reference/make_seq_options.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build a seq_options list for sequence‑based receptor filtering — make_seq_options","text":"query_col Character(1). Name receptor column compare (e.g. \"cdr3_aa\"). patterns Character vector sequences regular expressions search . method One \"exact\", \"regex\", \"lev\" (Levenshtein), \"hamm\" (Hamming).  Defaults \"exact\". max_dist Numeric distance threshold \"lev\" / \"hamm\" filtering.  Use NA (default) keep rows annotation. name_type Passed straight annotate_tbl_distance(); either \"index\" (default) \"pattern\".","code":""},{"path":"https://immunomind.github.io/immundata/reference/make_seq_options.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build a seq_options list for sequence‑based receptor filtering — make_seq_options","text":"named list suitable seq_options argument filter_receptors().","code":""},{"path":[]},{"path":"https://immunomind.github.io/immundata/reference/mutate_immundata.html","id":null,"dir":"Reference","previous_headings":"","what":"Modify or Add Columns to ImmunData Annotations — mutate_immundata","title":"Modify or Add Columns to ImmunData Annotations — mutate_immundata","text":"Applies transformations $annotations table within ImmunData object, similar dplyr::mutate. allows adding new columns modifying existing non-schema columns using standard dplyr expressions. Additionally, can add new columns based sequence comparisons (exact match, regular expression matching, distance calculation) specified patterns.","code":""},{"path":"https://immunomind.github.io/immundata/reference/mutate_immundata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Modify or Add Columns to ImmunData Annotations — mutate_immundata","text":"","code":"mutate_immundata(idata, ..., seq_options = NULL)  # S3 method for class 'ImmunData' mutate(.data, ..., seq_options = NULL)"},{"path":"https://immunomind.github.io/immundata/reference/mutate_immundata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Modify or Add Columns to ImmunData Annotations — mutate_immundata","text":"idata, .data ImmunData object. ... dplyr::mutate-style named expressions (e.g., new_col = existing_col * 2, category = ifelse(value > 10, \"high\", \"low\")). applied first. Important: use names new modified columns conflict core ImmunData schema columns (retrieved via imd_schema()). seq_options Optional named list specifying sequence-based annotation options. Use make_seq_options() convenient creation. See filter_immundata documentation (?filter_immundata) details section list structure (query_col, patterns, method, name_type). max_dist ignored mutation. NULL (default), sequence-based columns added.","code":""},{"path":"https://immunomind.github.io/immundata/reference/mutate_immundata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Modify or Add Columns to ImmunData Annotations — mutate_immundata","text":"new ImmunData object $annotations table modified according provided expressions seq_options. $repertoires table (present) carried unchanged input idata.","code":""},{"path":"https://immunomind.github.io/immundata/reference/mutate_immundata.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Modify or Add Columns to ImmunData Annotations — mutate_immundata","text":"function operates two main steps: Standard Mutations (...): Applies standard dplyr::mutate-style expressions provided ... $annotations table. can create new columns modify existing ones, modify columns defined core ImmunData schema (e.g., receptor_id, cell_id). error occur attempt . Sequence-based Annotations (seq_options): seq_options provided, function calculates sequence similarities distances adds corresponding new columns $annotations table. method = \"exact\": Adds boolean columns (TRUE/FALSE) indicating whether query_col value exactly matches pattern. Column names generated using prefix (e.g., sim_exact_) pattern index. method = \"regex\": Uses annotate_tbl_regex add columns indicating matches regular expression pattern query_col. exact nature added columns depends annotate_tbl_regex (e.g., boolean flags captured groups). method = \"lev\" method = \"hamm\": Uses annotate_tbl_distance calculate Levenshtein Hamming distances query_col pattern, adding columns containing numeric distances. max_dist ignored context (internally treated NA) distances calculated added, used filtering. naming new sequence-based columns depends name_type option within seq_options internal helper functions like make_pattern_columns. Prefixes like sim_exact_, sim_regex_, dist_lev_, dist_hamm_ typically used based schema. $repertoires table, present input idata, copied output object without modification. function affects $annotations table.","code":""},{"path":[]},{"path":"https://immunomind.github.io/immundata/reference/mutate_immundata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Modify or Add Columns to ImmunData Annotations — mutate_immundata","text":"","code":"# Basic setup (assuming idata_test is a valid ImmunData object) # print(idata_test)  if (FALSE) { # \\dontrun{ # Example 1: Add a simple derived column idata_mut1 <- mutate(idata_test, V_family = substr(V_gene, 1, 5)) print(idata_mut1$annotations)  # Example 2: Add multiple columns and modify one (if 'custom_score' exists) # Note: Avoid modifying core schema columns like 'V_gene' itself. idata_mut2 <- mutate(idata_test,   V_basic = gsub(\"-.*\", \"\", V_gene),   J_len = nchar(J_gene),   custom_score = custom_score * 1.1 ) # Fails if custom_score doesn't exist print(idata_mut2$annotations)  # Example 3: Add boolean columns for exact CDR3 matches cdr3_patterns <- c(\"CARGLGLVFYGMDVW\", \"CARDNRGAVAGVFGEAFYW\") seq_opts_exact <- make_seq_options(   query_col = \"CDR3_aa\",   patterns = cdr3_patterns,   method = \"exact\",   name_type = \"pattern\" ) # Name cols by pattern idata_mut_exact <- mutate(idata_test, seq_options = seq_opts_exact) # Look for new columns like 'sim_exact_CARGLGLVFYGMDVW' print(idata_mut_exact$annotations)  # Example 4: Add Levenshtein distance columns for a CDR3 pattern seq_opts_lev <- make_seq_options(   query_col = \"CDR3_aa\",   patterns = \"CARGLGLVFYGMDVW\",   method = \"lev\",   name_type = \"index\" ) # Name col like 'dist_lev_1' idata_mut_lev <- mutate(idata_test, seq_options = seq_opts_lev) # Look for new column 'dist_lev_1' (or similar based on schema) print(idata_mut_lev$annotations)  # Example 5: Combine standard mutation and sequence annotation seq_opts_regex <- make_seq_options(   query_col = \"V_gene\",   patterns = c(ighv1 = \"^IGHV1-\", ighv3 = \"^IGHV3-\"),   method = \"regex\",   name_type = \"pattern\" ) idata_mut_combo <- mutate(idata_test,   chain_upper = toupper(chain),   seq_options = seq_opts_regex ) # Look for 'chain_upper' and regex match columns (e.g., 'sim_regex_ighv1') print(idata_mut_combo) } # }"},{"path":"https://immunomind.github.io/immundata/reference/preprocess_postprocess.html","id":null,"dir":"Reference","previous_headings":"","what":"Preprocessing and postprocessing of input immune repertoire files — make_default_preprocessing","title":"Preprocessing and postprocessing of input immune repertoire files — make_default_preprocessing","text":"Preprocessing postprocessing input immune repertoire files","code":""},{"path":"https://immunomind.github.io/immundata/reference/preprocess_postprocess.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Preprocessing and postprocessing of input immune repertoire files — make_default_preprocessing","text":"","code":"make_default_preprocessing(format = c(\"airr\", \"10x\"))  make_default_postprocessing()  make_exclude_columns(cols = imd_drop_cols(\"airr\"))  make_productive_filter(col_name = c(\"productive\"), truthy = TRUE)  make_barcode_prefix(prefix_col = \"Prefix\")"},{"path":"https://immunomind.github.io/immundata/reference/preprocess_postprocess.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Preprocessing and postprocessing of input immune repertoire files — make_default_preprocessing","text":"format make_default_preprocessing(), character string specifying input data format. Currently supports \"airr\" (default) \"10x\". determines default set columns exclude values considered \"productive\". cols make_exclude_columns(), character vector column names removed dataset. Defaults imd_drop_cols(\"airr\"). empty, returned function remove columns. col_name make_productive_filter(), character vector potential column names indicate sequence productivity (e.g., \"productive\"). first matching column found dataset used. truthy make_productive_filter(), value vector values signify productive sequence col_name column. Can logical TRUE (default \"airr\" format) character vector strings (e.g., c(\"true\", \"TRUE\", \"True\", \"t\", \"T\", \"1\") \"10x\" format). prefix_col make_barcode_prefix(), name column dataset contains prefix string added cell barcode. Defaults \"Prefix\". barcode column identified internally via imd_schema(\"barcode\").","code":""},{"path":"https://immunomind.github.io/immundata/reference/preprocess_postprocess.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Preprocessing and postprocessing of input immune repertoire files — make_default_preprocessing","text":"make_* function returns new function. returned function takes dataset first argument ... additional arguments, performs specific processing step. make_default_preprocessing() make_default_postprocessing() return named list functions.","code":""},{"path":"https://immunomind.github.io/immundata/reference/preprocess_postprocess.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Preprocessing and postprocessing of input immune repertoire files — make_default_preprocessing","text":"collection \"maker\" functions generates common preprocessing postprocessing function steps tailored immune repertoire data. make_* function returns new function can applied dataset. functions designed flexible components constructing custom data processing workflows. functions generated factories typically expect dataset (e.g., duckplyr annotations) first argument may accept additional arguments via ... (though often unused predefined steps). make_default_preprocessing() make_default_postprocessing() assemble list processing functions. individual make_exclude_columns(), make_productive_filter(), make_barcode_prefix() functions create specific transformation steps. steps often used reading data standardize formats, filter unwanted records, enrich information like cell barcodes. designed gracefully handle cases operation applicable (e.g., specified column found) issuing warning returning dataset unmodified.","code":""},{"path":"https://immunomind.github.io/immundata/reference/preprocess_postprocess.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Preprocessing and postprocessing of input immune repertoire files — make_default_preprocessing","text":"make_default_preprocessing(): Creates default list preprocessing functions suitable \"airr\" \"10x\" formatted data. typically includes steps exclude unnecessary columns filter productive sequences. make_default_postprocessing(): Creates default list postprocessing functions, adding prefix cell barcodes. make_exclude_columns(): Creates function , applied dataset, removes specified set columns. make_productive_filter(): Creates function filters dataset retain rows sequences marked productive, based specified column set \"truthy\" values. make_barcode_prefix(): Creates function prepends prefix (sourced specified column dataset) cell barcodes.","code":""},{"path":[]},{"path":"https://immunomind.github.io/immundata/reference/read_immundata.html","id":null,"dir":"Reference","previous_headings":"","what":"Load a saved ImmunData from disk — read_immundata","title":"Load a saved ImmunData from disk — read_immundata","text":"Reconstructs ImmunData object files previously saved directory write_immundata() internal saving step read_repertoires(). reads annotations.parquet file main data metadata.json retrieve necessary receptor repertoire schemas.","code":""},{"path":"https://immunomind.github.io/immundata/reference/read_immundata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Load a saved ImmunData from disk — read_immundata","text":"","code":"read_immundata(path, prudence = \"stingy\", verbose = TRUE)"},{"path":"https://immunomind.github.io/immundata/reference/read_immundata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Load a saved ImmunData from disk — read_immundata","text":"path Character(1). Path directory containing saved ImmunData files (annotations.parquet metadata.json). prudence Character(1). Controls strictness type inference reading Parquet file, passed duckplyr::read_parquet_duckdb(). Default \"stingy\" likely implies stricter type checking safer inference. verbose Logical(1). TRUE (default), prints informative messages using cli loading. Set FALSE quiet operation.","code":""},{"path":"https://immunomind.github.io/immundata/reference/read_immundata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Load a saved ImmunData from disk — read_immundata","text":"new ImmunData object reconstructed saved files. repertoire information saved, recalculated included.","code":""},{"path":"https://immunomind.github.io/immundata/reference/read_immundata.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Load a saved ImmunData from disk — read_immundata","text":"function expects directory structure created write_immundata(), containing least: annotations.parquet: main annotation data table. metadata.json: Contains package version, receptor schema, optionally repertoire schema. loading process involves: Checking specified path directory contains required annotations.parquet metadata.json files. Reading metadata.json using jsonlite::read_json(). Reading annotations.parquet using duckplyr::read_parquet_duckdb() specified prudence level. Extracting receptor_schema repertoire_schema loaded metadata. Instantiating new ImmunData object using loaded annotations data receptor_schema. non-empty repertoire_schema found metadata, calls agg_repertoires() newly created object recalculate attach repertoire-level information based schema.","code":""},{"path":[]},{"path":"https://immunomind.github.io/immundata/reference/read_immundata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Load a saved ImmunData from disk — read_immundata","text":"","code":"if (FALSE) { # \\dontrun{ # Assume 'my_idata' is an ImmunData object created previously # my_idata <- read_repertoires(...)  # Define a temporary directory for saving save_dir <- tempfile(\"saved_immundata_\")  # Save the ImmunData object write_immundata(my_idata, save_dir)  # --- Later, in a new session or script ---  # Load the ImmunData object back from the directory loaded_idata <- read_immundata(save_dir)  # Verify the loaded object print(loaded_idata) # compare_methods(my_idata$annotations, loaded_idata$annotations) # If available  # Clean up unlink(save_dir, recursive = TRUE) } # }"},{"path":"https://immunomind.github.io/immundata/reference/read_metadata.html","id":null,"dir":"Reference","previous_headings":"","what":"Load and Validate Metadata Table for Immune Repertoire Files — read_metadata","title":"Load and Validate Metadata Table for Immune Repertoire Files — read_metadata","text":"function loads metadata table either file path data frame, validates presence column repertoire file paths, converts file paths absolute paths. used support flexible pipelines loading bulk single-cell immune repertoire data across samples. input file path, function attempts read readr::read_delim. input data frame, checks whether file paths absolute; relative paths allowed metadata loaded file. warns user many files listed metadata table missing, stops execution none files exist. column file paths normalized renamed match internal filename schema.","code":""},{"path":"https://immunomind.github.io/immundata/reference/read_metadata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Load and Validate Metadata Table for Immune Repertoire Files — read_metadata","text":"","code":"read_metadata(metadata, filename_col = \"File\", delim = \"\\t\", ...)"},{"path":"https://immunomind.github.io/immundata/reference/read_metadata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Load and Validate Metadata Table for Immune Repertoire Files — read_metadata","text":"metadata metadata table. Can either: data frame metadata, path text/TSV/CSV file can read readr::read_delim. filename_col string specifying name column metadata table contains paths repertoire files. Defaults \"File\". delim Delimiter used read metadata file (path provided). Defaults \"\\t\". ... Additional arguments passed readr::read_delim() reading metadata file.","code":""},{"path":"https://immunomind.github.io/immundata/reference/read_metadata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Load and Validate Metadata Table for Immune Repertoire Files — read_metadata","text":"validated updated metadata data frame absolute file paths, additional column renamed according IMD_GLOBALS$schema$filename.","code":""},{"path":"https://immunomind.github.io/immundata/reference/read_repertoires.html","id":null,"dir":"Reference","previous_headings":"","what":"Read and process immune repertoire files to immundata — read_repertoires","title":"Read and process immune repertoire files to immundata — read_repertoires","text":"main function reading immune repertoire data immundata framework. reads one repertoire files (AIRR TSV, 10X CSV, Parquet), performs optional preprocessing column renaming, aggregates sequences receptors based provided schema, optionally joins external metadata, performs optional postprocessing, returns ImmunData object. function handles different data types (bulk, single-cell) based presence barcode_col count_col. efficiency large datasets, processes data saves intermediate results (annotations) Parquet file loading back final ImmunData object.","code":""},{"path":"https://immunomind.github.io/immundata/reference/read_repertoires.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read and process immune repertoire files to immundata — read_repertoires","text":"","code":"read_repertoires(   path,   schema,   metadata = NULL,   barcode_col = NULL,   count_col = NULL,   locus_col = NULL,   umi_col = NULL,   preprocess = make_default_preprocessing(),   postprocess = make_default_postprocessing(),   rename_columns = imd_rename_cols(\"10x\"),   enforce_schema = TRUE,   metadata_file_col = \"File\",   output_folder = NULL,   repertoire_schema = NULL )"},{"path":"https://immunomind.github.io/immundata/reference/read_repertoires.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read and process immune repertoire files to immundata — read_repertoires","text":"path Character vector. Path(s) input repertoire files (e.g., \"/path//data/*.tsv.gz\"). Supports glob patterns via Sys.glob(). Files can Parquet, CSV, TSV, gzipped versions thereof. files must type. Alternatively, pass special string \"<metadata>\" read file paths metadata table (see metadata metadata_file_col params). schema Defines unique receptors identified. Can : character vector column names (e.g., c(\"v_call\", \"j_call\", \"junction_aa\")). schema object created make_receptor_schema(), allowing specification chains pairing (e.g., make_receptor_schema(features = c(\"v_call\", \"junction_aa\"), chains = c(\"TRA\", \"TRB\"))). metadata Optional. data frame containing metadata joined repertoire data, read read_metadata() function. path = \"<metadata>\", table must provided contain file paths column specified metadata_file_col. Default: NULL. barcode_col Character(1). Name column containing cell barcodes unique cell/clone identifiers single-cell data. Triggers single-cell processing logic agg_receptors(). Default: NULL. count_col Character(1). Name column containing UMI counts frequency counts bulk sequencing data. Triggers bulk processing logic agg_receptors(). Default: NULL. specified barcode_col also specified. locus_col Character(1). Name column specifying receptor chain locus (e.g., \"TRA\", \"TRB\", \"IGH\", \"IGK\", \"IGL\"). Required schema specifies chains pairing. Default: NULL. umi_col Character(1). Name column containing UMI counts single-cell data. Used paired-chain processing select abundant chain per barcode per locus. Default: NULL. preprocess List. named list functions apply sequentially raw data receptor aggregation. function accept data frame (duckplyr_df) first argument. See make_default_preprocessing() examples. Default: make_default_preprocessing(). Set NULL list() disable. postprocess List. named list functions apply sequentially annotation data receptor aggregation metadata joining. function accept data frame (duckplyr_df) first argument. See make_default_postprocessing() examples. Default: make_default_postprocessing(). Set NULL list() disable. rename_columns Named character vector. Optional mapping rename columns input files using dplyr::rename() syntax (e.g., c(new_name = \"old_name\", barcode = \"cell_id\")). Renaming happens preprocessing schema application. See imd_rename_cols() presets. Default: imd_rename_cols(\"10x\"). enforce_schema Logical(1). TRUE (default), reading multiple files requires exact columns types. FALSE, columns unioned across files (potentially slower, requires memory). Default: TRUE. metadata_file_col Character(1). name column metadata table contains full paths repertoire files. used path = \"<metadata>\". Default: \"File\". output_folder Character(1). Path directory intermediate processed annotation data saved annotations.parquet metadata.json. NULL (default), folder named immundata-<basename_without_ext> created directory first input file specified path. final ImmunData object reads saved files. Default: NULL. repertoire_schema Character vector Function. Defines columns used group annotations distinct repertoires (e.g., sample donor). provided, agg_repertoires() called loading add repertoire-level summaries metrics. Default: NULL.","code":""},{"path":"https://immunomind.github.io/immundata/reference/read_repertoires.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read and process immune repertoire files to immundata — read_repertoires","text":"ImmunData object containing processed receptor annotations. repertoire_schema provided, object also contain repertoire definitions summaries calculated agg_repertoires().","code":""},{"path":"https://immunomind.github.io/immundata/reference/read_repertoires.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read and process immune repertoire files to immundata — read_repertoires","text":"function executes following steps: Validates inputs. Determines list input files based path metadata. Checks file extensions. Reads data using duckplyr (read_parquet_duckdb read_csv_duckdb). Handles .gz. Applies column renaming rename_columns provided. Applies preprocessing steps sequentially preprocess provided. Aggregates sequences receptors using agg_receptors(), based schema, barcode_col, count_col, locus_col, umi_col. creates core annotation table. Joins metadata table provided. Applies postprocessing steps sequentially postprocess provided. Creates temporary ImmunData object memory. Determines output_folder path. Saves processed annotation table metadata using write_immundata() output_folder. Loads data back saved Parquet files using read_immundata() create final ImmunData object. ensures returned object backed efficient storage. repertoire_schema provided, calls agg_repertoires() loaded object define summarize repertoires. Returns final ImmunData object.","code":""},{"path":[]},{"path":"https://immunomind.github.io/immundata/reference/read_repertoires.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read and process immune repertoire files to immundata — read_repertoires","text":"","code":"if (FALSE) { # \\dontrun{ # # Example 1: single-chain, one file # # Read a single AIRR TSV file, defining receptors by V/J/CDR3_aa # Assume \"my_sample.tsv\" exists and follows AIRR format  # Create a dummy file for illustration airr_data <- data.frame(   sequence_id = paste0(\"seq\", 1:5),   v_call = c(\"TRBV1\", \"TRBV1\", \"TRBV2\", \"TRBV1\", \"TRBV3\"),   j_call = c(\"TRBJ1\", \"TRBJ1\", \"TRBJ2\", \"TRBJ1\", \"TRBJ1\"),   junction_aa = c(\"CASSL...\", \"CASSL...\", \"CASSD...\", \"CASSL...\", \"CASSF...\"),   productive = c(TRUE, TRUE, TRUE, FALSE, TRUE),   locus = c(\"TRB\", \"TRB\", \"TRB\", \"TRB\", \"TRB\") ) readr::write_tsv(airr_data, \"my_sample.tsv\")  # Define receptor schema receptor_def <- c(\"v_call\", \"j_call\", \"junction_aa\")  # Specify output folder out_dir <- tempfile(\"immundata_output_\")  # Read the data (disabling default preprocessing for this simple example) idata <- read_repertoires(   path = \"my_sample.tsv\",   schema = receptor_def,   output_folder = out_dir,   preprocess = NULL, # Disable default productive filter for demo   postprocess = NULL # Disable default barcode prefixing )  print(idata) print(idata$annotations)  # # Example 2: single-chain, multiple files # # Read multiple files using metadata # Create dummy files and metadata readr::write_tsv(airr_data[1:2, ], \"sample1.tsv\") readr::write_tsv(airr_data[3:5, ], \"sample2.tsv\") meta <- data.frame(   SampleID = c(\"S1\", \"S2\"),   Tissue = c(\"PBMC\", \"Tumor\"),   FilePath = c(normalizePath(\"sample1.tsv\"), normalizePath(\"sample2.tsv\")) ) readr::write_tsv(meta, \"metadata.tsv\")  idata_multi <- read_repertoires(   path = \"<metadata>\",   metadata = meta,   metadata_file_col = \"FilePath\",   schema = receptor_def,   repertoire_schema = \"SampleID\", # Aggregate by SampleID   output_folder = tempfile(\"immundata_multi_\"),   preprocess = make_default_preprocessing(\"airr\"), # Use default AIRR filters   postprocess = NULL )  print(idata_multi) print(idata_multi$repertoires) # Check repertoire summary  # Clean up dummy files file.remove(\"my_sample.tsv\", \"sample1.tsv\", \"sample2.tsv\", \"metadata.tsv\") unlink(out_dir, recursive = TRUE) unlink(attr(idata_multi, \"output_folder\"), recursive = TRUE) # Get path used by function } # }"},{"path":"https://immunomind.github.io/immundata/reference/write_immundata.html","id":null,"dir":"Reference","previous_headings":"","what":"Save ImmunData to disk — write_immundata","title":"Save ImmunData to disk — write_immundata","text":"Serializes essential components ImmunData object disk efficient storage later retrieval. saves core annotation data (idata$annotations) compressed Parquet file accompanying metadata (including receptor/repertoire schemas package version) JSON file within specified directory.","code":""},{"path":"https://immunomind.github.io/immundata/reference/write_immundata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Save ImmunData to disk — write_immundata","text":"","code":"write_immundata(idata, output_folder)"},{"path":"https://immunomind.github.io/immundata/reference/write_immundata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Save ImmunData to disk — write_immundata","text":"idata ImmunData object save. Must R6 object class ImmunData containing least $annotations table schema information ($schema_receptor, optionally $schema_repertoire). output_folder Character(1). Path directory output files written. directory exist, created recursively.","code":""},{"path":"https://immunomind.github.io/immundata/reference/write_immundata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Save ImmunData to disk — write_immundata","text":"Invisibly returns input idata object. primary effect creating metadata.json annotations.parquet files output_folder.","code":""},{"path":"https://immunomind.github.io/immundata/reference/write_immundata.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Save ImmunData to disk — write_immundata","text":"function performs following actions: Validates input idata object output_folder path. Creates output_folder exist. Constructs list containing metadata: immundata package version, receptor schema (idata$schema_receptor), repertoire schema (idata$schema_repertoire). Writes metadata list metadata.json within output_folder. Writes idata$annotations table (duckplyr_df similar) annotations.parquet within output_folder. Uses Zstandard compression (compression = \"zstd\", compression_level = 9) good balance file size read/write speed. Uses internal helper imd_files() determine standard filenames (metadata.json, annotations.parquet). receptor data (stored separately future versions) saved function; annotations linking receptors saved, along schema needed reconstruct/interpret .","code":""},{"path":[]},{"path":"https://immunomind.github.io/immundata/reference/write_immundata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Save ImmunData to disk — write_immundata","text":"","code":"if (FALSE) { # \\dontrun{ # Assume 'my_idata' is an ImmunData object created previously # my_idata <- read_repertoires(...)  # Define an output directory save_dir <- tempfile(\"saved_immundata_\")  # Save the ImmunData object write_immundata(my_idata, save_dir)  # Check the created files list.files(save_dir) # Should show \"annotations.parquet\" and \"metadata.json\"  # Clean up unlink(save_dir, recursive = TRUE) } # }"}]
